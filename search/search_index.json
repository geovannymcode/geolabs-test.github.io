{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Gu\u00eda R\u00e1pida: Preguntas de Entrevista Java","text":""},{"location":"#1-caracteristicas-de-java","title":"1) Caracter\u00edsticas de Java","text":"<ul> <li>Orientado a objetos</li> <li>Independiente de la plataforma (Write Once, Run Anywhere)</li> <li>Robusto (manejo de excepciones, recolector de basura)</li> <li>Seguro (sin punteros, sandbox de la JVM)</li> <li>Multihilo</li> <li>Arquitectura neutral (bytecode)</li> <li>Interpretado y de alto rendimiento (JIT)</li> <li>Distribuido (soporte de red integrado)</li> </ul>"},{"location":"#2-que-es-un-constructor","title":"2) \u00bfQu\u00e9 es un Constructor?","text":"<p>M\u00e9todo especial para inicializar objetos cuando se instancian. Tiene el mismo nombre que la clase, no tiene tipo de retorno y puede estar sobrecargado. Si no se define, Java proporciona un constructor por defecto sin par\u00e1metros.</p>"},{"location":"#3-variable-local-vs-variable-de-instancia","title":"3) Variable local vs. variable de instancia","text":"<ul> <li>Variable de instancia: Declarada dentro de la clase, fuera de m\u00e9todos. Cada objeto tiene su propia copia. Se inicializa autom\u00e1ticamente.</li> <li>Variable local: Declarada dentro de m\u00e9todos/bloques. Solo accesible en su \u00e1mbito. No se inicializa autom\u00e1ticamente.</li> </ul>"},{"location":"#4-que-es-una-clase","title":"4) \u00bfQu\u00e9 es una clase?","text":"<p>Plantilla para crear objetos que define atributos (estado) y m\u00e9todos (comportamiento). Act\u00faa como un tipo de dato que encapsula funcionalidad relacionada.</p>"},{"location":"#5-que-es-la-herencia","title":"5) \u00bfQu\u00e9 es la herencia?","text":"<p>Mecanismo donde una clase (subclase) adquiere propiedades y comportamientos de otra (superclase). Establece relaci\u00f3n \"es-un\" y permite reutilizaci\u00f3n de c\u00f3digo. En Java, se implementa con <code>extends</code> y solo permite herencia simple.</p>"},{"location":"#6-que-es-la-encapsulacion","title":"6) \u00bfQu\u00e9 es la encapsulaci\u00f3n?","text":"<p>Principio de ocultar los detalles internos y exponer solo lo necesario. Se implementa con modificadores de acceso (private, protected, public) y m\u00e9todos getter/setter. Proporciona control de acceso y facilita el mantenimiento.</p>"},{"location":"#7-que-es-el-polimorfismo","title":"7) \u00bfQu\u00e9 es el polimorfismo?","text":"<p>Capacidad de un objeto para tomar diferentes formas. En Java se implementa mediante:</p> <ul> <li>Sobrecarga: m\u00faltiples m\u00e9todos con el mismo nombre pero diferentes par\u00e1metros</li> <li>Sobreescritura: redefinir un m\u00e9todo heredado de la superclase</li> <li>Referencias de tipo interfaz/superclase a objetos de subclases</li> </ul>"},{"location":"#8-que-significa-sobrescribir-un-metodo","title":"8) \u00bfQu\u00e9 significa sobrescribir un m\u00e9todo?","text":"<p>Redefinir en una subclase un m\u00e9todo heredado de la superclase. Debe tener la misma firma (nombre, par\u00e1metros y tipo de retorno). Se usa la anotaci\u00f3n <code>@Override</code> para verificar que realmente se est\u00e1 sobrescribiendo. El m\u00e9todo en la subclase reemplaza al de la superclase cuando se llama desde un objeto de la subclase.</p>"},{"location":"#9-que-es-la-sobrecarga-de-metodos","title":"9) \u00bfQu\u00e9 es la sobrecarga de m\u00e9todos?","text":"<p>Definir m\u00faltiples m\u00e9todos con el mismo nombre pero diferentes par\u00e1metros (tipo, n\u00famero u orden). Java determina cu\u00e1l utilizar en tiempo de compilaci\u00f3n seg\u00fan los argumentos proporcionados. El tipo de retorno por s\u00ed solo no es suficiente para distinguir entre m\u00e9todos sobrecargados.</p>"},{"location":"#10-que-es-una-interfaz","title":"10) \u00bfQu\u00e9 es una Interfaz?","text":"<p>Contrato que especifica m\u00e9todos que una clase debe implementar. Define qu\u00e9 se debe hacer, pero no c\u00f3mo. Una clase puede implementar m\u00faltiples interfaces. Desde Java 8, pueden contener m\u00e9todos default y static con implementaci\u00f3n.</p>"},{"location":"#11-que-es-una-clase-abstracta","title":"11) \u00bfQu\u00e9 es una clase abstracta?","text":"<p>Clase que no puede ser instanciada directamente y est\u00e1 dise\u00f1ada para ser extendida. Puede contener m\u00e9todos abstractos (sin implementaci\u00f3n) y m\u00e9todos concretos. Una clase que extiende una clase abstracta debe implementar todos sus m\u00e9todos abstractos o ser tambi\u00e9n abstracta.</p>"},{"location":"#12-string-vs-stringbuilder-vs-stringbuffer","title":"12) String vs. StringBuilder vs. StringBuffer","text":"<ul> <li>String: Inmutable. Cada modificaci\u00f3n crea nuevo objeto.</li> <li>StringBuilder: Mutable, m\u00e1s eficiente para concatenaciones. No sincronizado (no thread-safe).</li> <li>StringBuffer: Similar a StringBuilder pero sincronizado (thread-safe), m\u00e1s lento.</li> </ul>"},{"location":"#13-hashmap-vs-hashtable","title":"13) HashMap vs. Hashtable","text":"<ul> <li>HashMap: No sincronizado, permite una clave null y m\u00faltiples valores null, m\u00e1s eficiente.</li> <li>Hashtable: Sincronizado (thread-safe), no permite claves/valores null, m\u00e1s lento.</li> </ul>"},{"location":"#14-constructores-vs-metodos","title":"14) Constructores vs. M\u00e9todos","text":"<ul> <li>Constructores: Mismo nombre que la clase, sin tipo de retorno, invocados con new, inicializan objetos.</li> <li>M\u00e9todos: Nombre diferente a la clase, tienen tipo de retorno (incluso void), invocados con referencias a objetos, realizan operaciones.</li> </ul>"},{"location":"#15-que-es-un-array","title":"15) \u00bfQu\u00e9 es un Array?","text":"<p>Estructura de datos que almacena elementos del mismo tipo en posiciones contiguas de memoria. Tama\u00f1o fijo definido en la creaci\u00f3n. Se accede a elementos por \u00edndice (0-based). Ejemplo: <code>int[] numeros = new int[5];</code></p>"},{"location":"#16-sobrecarga-solo-cambiando-tipo-de-retorno","title":"16) \u00bfSobrecarga solo cambiando tipo de retorno?","text":"<p>No. Java no permite sobrecargar m\u00e9todos cambiando solo el tipo de retorno. Debe haber diferencia en los par\u00e1metros (tipo, n\u00famero u orden).</p>"},{"location":"#17-clase-abstracta-vs-interfaz","title":"17) Clase abstracta vs. Interfaz","text":"<ul> <li>Clase abstracta: Puede tener m\u00e9todos con implementaci\u00f3n y variables de instancia, constructores, soporta herencia simple.</li> <li>Interfaz: Antes de Java 8, solo m\u00e9todos abstractos; despu\u00e9s, permite m\u00e9todos default y static. Variables solo public static final, no constructores, permite implementaci\u00f3n m\u00faltiple.</li> </ul>"},{"location":"#18-variable-estatica-en-java","title":"18) Variable est\u00e1tica en Java","text":"<p>Variable que pertenece a la clase, no a instancias. Se comparte entre todos los objetos. Se declara con <code>static</code> y se accede con <code>NombreClase.variable</code>. Se inicializa cuando la clase se carga en memoria.</p>"},{"location":"#19-bloque-estatico","title":"19) Bloque est\u00e1tico","text":"<p>Bloque de c\u00f3digo precedido por <code>static</code> que se ejecuta una sola vez cuando la clase se carga en memoria. Se usa para inicializar variables est\u00e1ticas o realizar acciones de inicializaci\u00f3n que deben ocurrir una sola vez.</p>"},{"location":"#20-uso-de-final-en-java","title":"20) Uso de final en Java","text":"<ul> <li>En variables: Constantes, no pueden cambiar de valor</li> <li>En m\u00e9todos: No pueden ser sobrescritos</li> <li>En clases: No pueden ser heredadas</li> </ul>"},{"location":"#21-tipos-de-excepciones","title":"21) Tipos de excepciones","text":"<ul> <li>Checked: Verificadas en compilaci\u00f3n, deben ser declaradas/capturadas (IOException)</li> <li>Unchecked (Runtime): No verificadas en compilaci\u00f3n (NullPointerException)</li> <li>Error: Problemas graves del sistema (OutOfMemoryError)</li> </ul>"},{"location":"#22-string-es-inmutable-o-mutable","title":"22) \u00bfString es inmutable o mutable?","text":"<p>Inmutable. Una vez creado un objeto String, su contenido no puede cambiar. Cualquier operaci\u00f3n que parezca modificarlo realmente crea un nuevo objeto String.</p>"},{"location":"#23-list-set-map","title":"23) List, Set, Map","text":"<ul> <li>List: Colecci\u00f3n ordenada que permite duplicados (ArrayList, LinkedList)</li> <li>Set: Colecci\u00f3n sin duplicados (HashSet, TreeSet)</li> <li>Map: Almacena pares clave-valor, sin claves duplicadas (HashMap, TreeMap)</li> </ul>"},{"location":"#24-por-que-arraylist-es-mejor-que-arrays","title":"24) \u00bfPor qu\u00e9 ArrayList es mejor que Arrays?","text":"<ul> <li>Tama\u00f1o din\u00e1mico (crece autom\u00e1ticamente)</li> <li>API rica en m\u00e9todos para manipular datos</li> <li>Admite solo objetos (no primitivos)</li> <li>F\u00e1cil conversi\u00f3n a/desde otros tipos de colecciones</li> <li>Implementa interfaces de colecci\u00f3n</li> </ul>"},{"location":"#25-arraylist-vs-linkedlist","title":"25) ArrayList vs. LinkedList","text":"<ul> <li>ArrayList: Implementado con array redimensionable. Acceso aleatorio eficiente O(1). Inserci\u00f3n/eliminaci\u00f3n ineficiente O(n) si no es al final.</li> <li>LinkedList: Implementado con lista doblemente enlazada. Acceso aleatorio ineficiente O(n). Inserci\u00f3n/eliminaci\u00f3n eficiente O(1) si se tiene el iterador posicionado.</li> </ul>"},{"location":"#26-arraylist-vs-vector","title":"26) ArrayList vs. Vector","text":"<ul> <li>ArrayList: No sincronizado (no thread-safe), m\u00e1s eficiente en entornos single-thread.</li> <li>Vector: Sincronizado (thread-safe), menos eficiente por sobrecarga de sincronizaci\u00f3n, crece 100% cuando se llena.</li> </ul>"},{"location":"#27-iterator-vs-listiterator","title":"27) Iterator vs. ListIterator","text":"<ul> <li>Iterator: Recorre colecciones en una direcci\u00f3n (adelante), solo permite eliminar.</li> <li>ListIterator: Solo para List, bidireccional (adelante/atr\u00e1s), permite eliminar, agregar y modificar elementos.</li> </ul>"},{"location":"#28-treeset-vs-sortedset","title":"28) TreeSet vs. SortedSet","text":"<p>SortedSet es una interfaz que define una colecci\u00f3n ordenada sin duplicados. TreeSet es la implementaci\u00f3n de SortedSet basada en un \u00e1rbol rojo-negro, que proporciona tiempo logar\u00edtmico para operaciones b\u00e1sicas.</p>"},{"location":"#29-hashmap-vs-hashtable","title":"29) HashMap vs. Hashtable","text":"<ul> <li>HashMap: No sincronizado, permite una clave null y valores null, implementaci\u00f3n m\u00e1s reciente y eficiente.</li> <li>Hashtable: Sincronizado (thread-safe), no permite claves/valores null, clase legacy.</li> </ul>"},{"location":"#30-iterator-vs-enumeration","title":"30) Iterator vs. Enumeration","text":"<ul> <li>Iterator: M\u00e1s moderno, permite eliminar elementos durante la iteraci\u00f3n, usado en todas las colecciones modernas.</li> <li>Enumeration: Interfaz legacy, solo lectura (no permite modificar), usado en clases antiguas como Vector y Hashtable.</li> </ul>"},{"location":"fp/","title":"Gu\u00eda de Entrevista: Java 8 y Programaci\u00f3n Funcional","text":""},{"location":"fp/#1-que-caracteristicas-importantes-se-introdujeron-en-java-8","title":"1) \u00bfQu\u00e9 caracter\u00edsticas importantes se introdujeron en Java 8?","text":"<ul> <li>Expresiones lambda: Funciones an\u00f3nimas sin clase <code>(a, b) -&gt; a + b</code></li> <li>Referencias a m\u00e9todos: Forma abreviada de lambda <code>String::valueOf</code></li> <li>Interfaces funcionales: Interfaces con un \u00fanico m\u00e9todo abstracto</li> <li>M\u00e9todos default y static en interfaces: Para extender interfaces sin romper compatibilidad</li> <li>API Stream: Para procesamiento funcional de colecciones</li> <li>Optional: Contenedor para valores potencialmente nulos</li> <li>Nueva API de Fecha y Hora: Reemplazo inmutable y thread-safe para Date/Calendar</li> <li>Nashorn: Motor JavaScript mejorado</li> </ul> <pre><code>// Ejemplo de uso de nuevas caracter\u00edsticas\nList&lt;String&gt; nombres = Arrays.asList(\"Ana\", \"Juan\", \"Pedro\");\nnombres.stream()                            // Stream API\n      .filter(s -&gt; s.length() &gt; 3)          // Lambda\n      .map(String::toUpperCase)             // Referencia a m\u00e9todo\n      .forEach(System.out::println);        // Referencia a m\u00e9todo\n</code></pre>"},{"location":"fp/#2-que-es-una-expresion-lambda-y-cual-es-su-caso-de-uso-ideal","title":"2) \u00bfQu\u00e9 es una expresi\u00f3n lambda y cu\u00e1l es su caso de uso ideal?","text":"<p>Una funci\u00f3n an\u00f3nima que puede referenciarse y pasarse como objeto. Caso de uso ideal: implementar interfaces funcionales de forma concisa.</p> <pre><code>// Antes de Java 8\nRunnable r = new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"Ejecutando\");\n    }\n};\n\n// Con lambda en Java 8\nRunnable r = () -&gt; System.out.println(\"Ejecutando\");\n</code></pre>"},{"location":"fp/#3-explique-la-sintaxis-de-una-expresion-lambda","title":"3) Explique la sintaxis de una expresi\u00f3n lambda","text":"<p>Componentes:</p> <ul> <li>Par\u00e1metros: Entre par\u00e9ntesis (opcionales si hay un solo par\u00e1metro sin tipo)</li> <li>Flecha <code>-&gt;</code>: Separa par\u00e1metros del cuerpo</li> <li>Cuerpo: Expresi\u00f3n \u00fanica o bloque de c\u00f3digo entre llaves</li> </ul> <p>Formatos: <pre><code>// Sin par\u00e1metros\n() -&gt; System.out.println(\"Hola\")\n\n// Un par\u00e1metro (par\u00e9ntesis opcionales)\nn -&gt; n * n\n(String s) -&gt; s.length()\n\n// M\u00faltiples par\u00e1metros\n(a, b) -&gt; a + b\n(int x, int y) -&gt; { return x + y; }\n\n// Bloque de c\u00f3digo (requiere return expl\u00edcito)\n(String s) -&gt; {\n    String result = s.toUpperCase();\n    return result;\n}\n</code></pre></p>"},{"location":"fp/#4-ejecute-un-hilo-usando-una-expresion-lambda","title":"4) Ejecute un hilo usando una expresi\u00f3n lambda","text":"<pre><code>// Antes de Java 8\nnew Thread(new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"Ejecutando hilo\");\n    }\n}).start();\n\n// Con lambda en Java 8\nnew Thread(() -&gt; System.out.println(\"Ejecutando hilo\")).start();\n</code></pre>"},{"location":"fp/#5-que-es-una-referencia-a-metodo","title":"5) \u00bfQu\u00e9 es una referencia a m\u00e9todo?","text":"<p>Una forma abreviada de expresi\u00f3n lambda que refiere a un m\u00e9todo existente. Se usa cuando la lambda simplemente llama a un m\u00e9todo.</p> <p>Tipos:</p> <ul> <li>A m\u00e9todo est\u00e1tico: <code>Math::abs</code></li> <li>A m\u00e9todo de instancia de objeto espec\u00edfico: <code>objeto::m\u00e9todo</code></li> <li>A m\u00e9todo de instancia de objeto arbitrario: <code>String::length</code></li> <li>A constructor: <code>ArrayList::new</code></li> </ul> <pre><code>// Lambda\nFunction&lt;String, Integer&gt; lambda = s -&gt; s.length();\n// Referencia a m\u00e9todo equivalente\nFunction&lt;String, Integer&gt; referencia = String::length;\n\n// Uso con forEach\nList&lt;String&gt; nombres = Arrays.asList(\"Ana\", \"Juan\", \"Carlos\");\nnombres.forEach(System.out::println);\n</code></pre>"},{"location":"fp/#6-que-es-una-interfaz-funcional","title":"6) \u00bfQu\u00e9 es una interfaz funcional?","text":"<p>Una interfaz con exactamente un m\u00e9todo abstracto. Se usa como tipo objetivo para expresiones lambda.</p> <pre><code>@FunctionalInterface  // Anotaci\u00f3n opcional\ninterface Calculadora {\n    int operar(int a, int b);  // \u00danico m\u00e9todo abstracto\n\n    // Puede tener m\u00e9todos default o static\n    default void mostrarInfo() {\n        System.out.println(\"Calculadora\");\n    }\n}\n\n// Implementaci\u00f3n con lambda\nCalculadora suma = (a, b) -&gt; a + b;\nint resultado = suma.operar(5, 3);  // 8\n</code></pre>"},{"location":"fp/#7-cuales-son-los-tipos-de-interfaces-funcionales-mas-comunes","title":"7) \u00bfCu\u00e1les son los tipos de interfaces funcionales m\u00e1s comunes?","text":"<p>Java 8 incluye varias interfaces funcionales en <code>java.util.function</code>:</p> <ul> <li> <p><code>Consumer&lt;T&gt;</code>: Acepta un valor, no devuelve nada - <code>accept(T t)</code> <pre><code>Consumer&lt;String&gt; imprimir = s -&gt; System.out.println(s);\n</code></pre></p> </li> <li> <p><code>Supplier&lt;T&gt;</code>: No acepta par\u00e1metros, devuelve un valor - <code>get()</code> <pre><code>Supplier&lt;Double&gt; aleatorio = () -&gt; Math.random();\n</code></pre></p> </li> <li> <p><code>Function&lt;T,R&gt;</code>: Acepta T, devuelve R - <code>apply(T t)</code> <pre><code>Function&lt;String, Integer&gt; longitud = s -&gt; s.length();\n</code></pre></p> </li> <li> <p><code>Predicate&lt;T&gt;</code>: Acepta T, devuelve boolean - <code>test(T t)</code> <pre><code>Predicate&lt;String&gt; esVacio = s -&gt; s.isEmpty();\n</code></pre></p> </li> <li> <p><code>UnaryOperator&lt;T&gt;</code>: Acepta T, devuelve T - <code>apply(T t)</code> <pre><code>UnaryOperator&lt;String&gt; mayusculas = s -&gt; s.toUpperCase();\n</code></pre></p> </li> <li> <p><code>BinaryOperator&lt;T&gt;</code>: Acepta dos T, devuelve T - <code>apply(T t1, T t2)</code> <pre><code>BinaryOperator&lt;Integer&gt; suma = (a, b) -&gt; a + b;\n</code></pre></p> </li> </ul>"},{"location":"fp/#8-que-es-un-metodo-default-y-un-metodo-static-en-interfaces","title":"8) \u00bfQu\u00e9 es un m\u00e9todo default y un m\u00e9todo static en interfaces?","text":"<p>M\u00e9todo default: M\u00e9todo con implementaci\u00f3n dentro de una interfaz. Permite a\u00f1adir funcionalidades a interfaces existentes sin romper compatibilidad.</p> <p>M\u00e9todo static: M\u00e9todo est\u00e1tico en interfaz, pertenece solo a la interfaz y no a implementaciones.</p> <pre><code>interface Veh\u00edculo {\n    void acelerar();  // M\u00e9todo abstracto tradicional\n\n    // M\u00e9todo default (todas las implementaciones lo heredan)\n    default void tocarBocina() {\n        System.out.println(\"\u00a1Beep!\");\n    }\n\n    // M\u00e9todo static (pertenece solo a la interfaz)\n    static Veh\u00edculo crearVeh\u00edculoEl\u00e9ctrico() {\n        return new Veh\u00edculoEl\u00e9ctrico();\n    }\n}\n</code></pre>"},{"location":"fp/#9-que-condiciones-deben-cumplirse-para-que-una-expresion-lambda-coincida-con-una-interfaz-funcional","title":"9) \u00bfQu\u00e9 condiciones deben cumplirse para que una expresi\u00f3n lambda coincida con una interfaz funcional?","text":"<ol> <li>La interfaz debe tener exactamente un m\u00e9todo abstracto</li> <li>Los par\u00e1metros de la lambda deben coincidir con los del m\u00e9todo</li> <li>El tipo de retorno de la lambda debe ser compatible con el del m\u00e9todo</li> </ol>"},{"location":"fp/#10-que-es-la-clase-optional","title":"10) \u00bfQu\u00e9 es la clase Optional?","text":"<p>Contenedor que puede contener un valor no nulo o estar vac\u00edo. Evita <code>NullPointerException</code> y proporciona operaciones para tratar valores ausentes.</p> <pre><code>// Crear Optional\nOptional&lt;String&gt; empty = Optional.empty();\nOptional&lt;String&gt; nombre = Optional.of(\"Juan\");  // No puede ser null\nOptional&lt;String&gt; posibleNull = Optional.ofNullable(obtenerNombre());  // Puede ser null\n\n// Usar Optional\nif (nombre.isPresent()) {\n    System.out.println(nombre.get());\n}\n\n// Mejor forma (funcional)\nnombre.ifPresent(n -&gt; System.out.println(n));\n\n// Valor alternativo si no existe\nString resultado = nombre.orElse(\"Desconocido\");\n\n// Lanzar excepci\u00f3n si no existe\nString valor = nombre.orElseThrow(() -&gt; new NoSuchElementException());\n\n// Transformar si existe (sin NullPointerException)\nOptional&lt;Integer&gt; longitud = nombre.map(String::length);\n</code></pre>"},{"location":"fp/#11-que-es-la-api-stream-y-como-se-usa","title":"11) \u00bfQu\u00e9 es la API Stream y c\u00f3mo se usa?","text":"<p>Secuencia de elementos que soporta operaciones agregadas. Permite procesamiento de datos declarativo (qu\u00e9 hacer, no c\u00f3mo).</p> <p>Componentes:</p> <ol> <li>Fuente de datos (colecci\u00f3n, array)</li> <li>Operaciones intermedias (transforman el stream)</li> <li>Operaci\u00f3n terminal (produce resultado)</li> </ol> <pre><code>List&lt;String&gt; nombres = Arrays.asList(\"Ana\", \"Juan\", \"Carlos\", \"Pedro\");\n\n// Filtrar nombres que empiezan con 'J' y convertir a may\u00fasculas\nList&lt;String&gt; resultado = nombres.stream()        // Fuente\n    .filter(n -&gt; n.startsWith(\"J\"))              // Intermedia\n    .map(String::toUpperCase)                    // Intermedia\n    .collect(Collectors.toList());               // Terminal\n</code></pre>"},{"location":"fp/#12-que-son-las-operaciones-intermedias-y-terminales","title":"12) \u00bfQu\u00e9 son las operaciones intermedias y terminales?","text":"<p>Operaciones intermedias:</p> <ul> <li>Devuelven un nuevo stream</li> <li>Son perezosas (no se ejecutan hasta que haya una operaci\u00f3n terminal)</li> <li>Ejemplos: <code>filter()</code>, <code>map()</code>, <code>sorted()</code>, <code>distinct()</code>, <code>limit()</code></li> </ul> <p>Operaciones terminales:</p> <ul> <li>Producen un resultado o efecto secundario</li> <li>Consumen el stream (no se puede reutilizar)</li> <li>Ejemplos: <code>forEach()</code>, <code>collect()</code>, <code>reduce()</code>, <code>count()</code>, <code>anyMatch()</code></li> </ul> <pre><code>long contador = Stream.of(1, 2, 3, 4, 5)\n    .filter(n -&gt; {                     // Intermedia\n        System.out.println(\"Filtrando: \" + n);\n        return n % 2 == 0;\n    })\n    .count();                          // Terminal\n// Solo se procesan los elementos cuando se llega a count()\n</code></pre>"},{"location":"fp/#13-que-es-un-collector-y-como-se-usa","title":"13) \u00bfQu\u00e9 es un Collector y c\u00f3mo se usa?","text":"<p>Mecanismo para combinar elementos de un stream en un resultado final (lista, mapa, cadena, etc.).</p> <pre><code>// Recolectar en una lista\nList&lt;String&gt; lista = stream.collect(Collectors.toList());\n\n// Recolectar en un conjunto\nSet&lt;String&gt; conjunto = stream.collect(Collectors.toSet());\n\n// Recolectar en una cadena\nString cadena = stream.collect(Collectors.joining(\", \"));\n\n// Agrupar por alguna propiedad\nMap&lt;Integer, List&lt;Persona&gt;&gt; porEdad = personas.stream()\n    .collect(Collectors.groupingBy(Persona::getEdad));\n\n// Particionar seg\u00fan un predicado\nMap&lt;Boolean, List&lt;Persona&gt;&gt; adultos = personas.stream()\n    .collect(Collectors.partitioningBy(p -&gt; p.getEdad() &gt;= 18));\n</code></pre>"},{"location":"fp/#14-cual-es-la-diferencia-entre-las-operaciones-map-y-flatmap","title":"14) \u00bfCu\u00e1l es la diferencia entre las operaciones map y flatMap?","text":"<p>map: Transforma cada elemento en exactamente otro elemento (uno a uno). <pre><code>// String -&gt; Integer (longitud)\nStream&lt;Integer&gt; longitudes = Stream.of(\"a\", \"bc\", \"def\")\n    .map(String::length);  // [1, 2, 3]\n</code></pre></p> <p>flatMap: Transforma cada elemento en 0 o m\u00e1s elementos y \"aplana\" el resultado (uno a muchos). <pre><code>// Lista de listas -&gt; Lista plana\nList&lt;List&lt;Integer&gt;&gt; listas = Arrays.asList(\n    Arrays.asList(1, 2),\n    Arrays.asList(3, 4, 5)\n);\nList&lt;Integer&gt; plana = listas.stream()\n    .flatMap(Collection::stream)  // [1, 2, 3, 4, 5]\n    .collect(Collectors.toList());\n</code></pre></p>"},{"location":"fp/#15-que-ventajas-ofrece-la-nueva-api-de-fecha-y-hora-en-java-8","title":"15) \u00bfQu\u00e9 ventajas ofrece la nueva API de Fecha y Hora en Java 8?","text":"<ul> <li>Inmutable y thread-safe</li> <li>M\u00e1s intuitiva y consistente</li> <li>Mejor soporte para zonas horarias</li> <li>Separaci\u00f3n clara de conceptos</li> <li>Mayor precisi\u00f3n (nanosegundos)</li> </ul> <pre><code>// Fecha actual\nLocalDate hoy = LocalDate.now();  // 2023-09-10\n\n// Hora actual\nLocalTime ahora = LocalTime.now();  // 15:30:45.123\n\n// Fecha y hora\nLocalDateTime fechaHora = LocalDateTime.now();\n\n// Con zona horaria\nZonedDateTime zonaHora = ZonedDateTime.now(ZoneId.of(\"Europe/Madrid\"));\n\n// Manipulaci\u00f3n (inmutable)\nLocalDate ma\u00f1ana = hoy.plusDays(1);\nLocalDate primerD\u00edaMes = hoy.withDayOfMonth(1);\n\n// Formateo\nDateTimeFormatter formato = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\nString fechaFormateada = hoy.format(formato);  // \"10/09/2023\"\n</code></pre>"},{"location":"fp/#16-que-es-la-programacion-funcional","title":"16) \u00bfQu\u00e9 es la programaci\u00f3n funcional?","text":"<p>Paradigma de programaci\u00f3n donde las funciones son ciudadanas de primera clase y los programas se construyen componiendo funciones puras sin efectos secundarios.</p> <p>Caracter\u00edsticas en Java 8: - Funciones como objetos (lambdas) - Inmutabilidad (evitar cambios de estado) - Operaciones de orden superior (funciones que operan sobre otras funciones) - Evaluaci\u00f3n perezosa (streams) - Procesamiento de colecciones mediante operaciones funcionales</p> <p>Beneficios: - C\u00f3digo m\u00e1s conciso y expresivo - Menos errores por estado mutable - Mejor paralelizaci\u00f3n - Mayor capacidad de composici\u00f3n</p>"},{"location":"fp/#17-que-son-las-operaciones-terminales-y-que-hacen","title":"17) \u00bfQu\u00e9 son las operaciones terminales y qu\u00e9 hacen?","text":"<p>Las operaciones terminales son las que cierran un Stream y devuelven un resultado. Marcan el final del procesamiento y desencadenan la ejecuci\u00f3n de todas las operaciones intermedias pendientes.</p> <p>Operaciones terminales comunes: - <code>collect()</code>: Acumula elementos en una colecci\u00f3n - <code>forEach()</code>: Ejecuta una acci\u00f3n para cada elemento - <code>reduce()</code>: Combina elementos en un \u00fanico resultado - <code>count()</code>: Cuenta elementos - <code>min()/max()</code>: Encuentra el valor m\u00ednimo/m\u00e1ximo - <code>anyMatch()/allMatch()/noneMatch()</code>: Comprueba condiciones</p> <pre><code>// Ejemplos de operaciones terminales\nlong cantidad = stream.count();\nOptional&lt;Persona&gt; masJoven = personas.stream().min(Comparator.comparing(Persona::getEdad));\nboolean todosMayores = personas.stream().allMatch(p -&gt; p.getEdad() &gt;= 18);\nint suma = numeros.stream().reduce(0, Integer::sum);\n</code></pre>"},{"location":"fp/#18-recolecte-elementos-de-un-stream-en-una-lista-usando-el-metodo-tolist","title":"18) Recolecte elementos de un Stream en una Lista usando el m\u00e9todo toList()","text":"<pre><code>// Java 8\nList&lt;Integer&gt; numeros = Stream.of(1, 2, 3)\n    .collect(Collectors.toList());\n\n// Java 16+\nList&lt;Integer&gt; numeros = Stream.of(1, 2, 3)\n    .toList();  // M\u00e9todo m\u00e1s corto en versiones recientes\n</code></pre>"},{"location":"fp/#19-determine-el-numero-de-elementos-en-un-stream","title":"19) Determine el n\u00famero de elementos en un Stream","text":"<pre><code>// Crear un Stream\nStream&lt;String&gt; stream = Stream.of(\"a\", \"b\", \"c\", \"d\", \"e\");\n\n// Contar elementos\nlong cantidad = stream.count();\nSystem.out.println(\"N\u00famero de elementos: \" + cantidad);  // 5\n</code></pre>"},{"location":"fp/#20-para-que-se-usa-la-palabra-clave-random","title":"20) \u00bfPara qu\u00e9 se usa la palabra clave random?","text":"<p>En Java 8, la palabra <code>random</code> no es una palabra clave como tal, pero hay varios m\u00e9todos y clases para generar valores aleatorios:</p> <pre><code>// Usando Random\nRandom random = new Random();\nint numAleatorio = random.nextInt(100);  // 0-99\n\n// Usando ThreadLocalRandom (Java 7+)\nint aleatorio = ThreadLocalRandom.current().nextInt(1, 101);  // 1-100\n\n// Usando streams de n\u00fameros aleatorios (Java 8)\nIntStream numerosAleatorios = random.ints(5, 1, 100);  // 5 n\u00fameros entre 1-99\nnumerosAleatorios.forEach(System.out::println);\n</code></pre>"},{"location":"fp/#21-que-es-un-supplier","title":"21) \u00bfQu\u00e9 es un Supplier?","text":"<p>Un <code>Supplier&lt;T&gt;</code> es una interfaz funcional que no recibe argumentos y produce un resultado de tipo T. Se usa cuando queremos retrasar la creaci\u00f3n de un objeto o la evaluaci\u00f3n de una expresi\u00f3n.</p> <pre><code>// Definici\u00f3n\n@FunctionalInterface\npublic interface Supplier&lt;T&gt; {\n    T get();\n}\n\n// Ejemplos\nSupplier&lt;Double&gt; aleatorio = () -&gt; Math.random();\nSupplier&lt;LocalDate&gt; hoy = LocalDate::now;\nSupplier&lt;List&lt;String&gt;&gt; listaVac\u00eda = ArrayList::new;\n\n// Uso\nDouble valor = aleatorio.get();  // Obtiene un n\u00famero aleatorio\nList&lt;String&gt; lista = listaVac\u00eda.get();  // Crea una nueva lista\n</code></pre>"},{"location":"fp/#22-que-es-un-consumer","title":"22) \u00bfQu\u00e9 es un Consumer?","text":"<p>Un <code>Consumer&lt;T&gt;</code> es una interfaz funcional que acepta un argumento de tipo T y no devuelve nada. Utilizado para realizar operaciones o acciones en un objeto.</p> <pre><code>// Definici\u00f3n\n@FunctionalInterface\npublic interface Consumer&lt;T&gt; {\n    void accept(T t);\n}\n\n// Ejemplos\nConsumer&lt;String&gt; imprimir = System.out::println;\nConsumer&lt;List&lt;String&gt;&gt; agregarItem = lista -&gt; lista.add(\"Nuevo\");\nConsumer&lt;Integer&gt; procesarYMostrar = n -&gt; {\n    int resultado = n * 2;\n    System.out.println(\"El doble es: \" + resultado);\n};\n\n// Uso\nimprimir.accept(\"Hola mundo\");  // Imprime \"Hola mundo\"\nList&lt;String&gt; items = new ArrayList&lt;&gt;();\nagregarItem.accept(items);  // Agrega \"Nuevo\" a la lista\n</code></pre>"},{"location":"fp/#23-cual-es-la-sintaxis-para-una-interfaz-predicate","title":"23) \u00bfCu\u00e1l es la sintaxis para una interfaz Predicate?","text":"<p>Un <code>Predicate&lt;T&gt;</code> es una interfaz funcional que acepta un argumento de tipo T y devuelve un boolean. Se usa para filtrar o comprobar condiciones.</p> <pre><code>// Definici\u00f3n\n@FunctionalInterface\npublic interface Predicate&lt;T&gt; {\n    boolean test(T t);\n}\n\n// Ejemplos\nPredicate&lt;String&gt; esVacio = String::isEmpty;\nPredicate&lt;Integer&gt; esPar = n -&gt; n % 2 == 0;\nPredicate&lt;Persona&gt; esMayor = p -&gt; p.getEdad() &gt;= 18;\n\n// Uso\nboolean resultado = esPar.test(4);  // true\nList&lt;Integer&gt; pares = numeros.stream()\n    .filter(esPar)\n    .collect(Collectors.toList());\n</code></pre>"},{"location":"fp/#24-que-es-la-programacion-funcional","title":"24) \u00bfQu\u00e9 es la programaci\u00f3n funcional?","text":"<p>La programaci\u00f3n funcional es un paradigma donde los programas se construyen aplicando y componiendo funciones. Caracter\u00edsticas principales:</p> <ul> <li>Funciones como \"ciudadanos de primera clase\"</li> <li>Inmutabilidad (evitar cambios de estado)</li> <li>Ausencia de efectos secundarios</li> <li>Transparencia referencial (mismo resultado para misma entrada)</li> <li>Funciones puras (no dependen de estado externo)</li> </ul> <p>Ventajas en Java:</p> <ul> <li>C\u00f3digo m\u00e1s conciso y declarativo</li> <li>Mejor manejo de concurrencia</li> <li>Reducci\u00f3n de errores por estado mutable</li> <li>Mayor facilidad para pruebas</li> <li>Mejor paralelizaci\u00f3n</li> </ul> <pre><code>// Ejemplo de estilo imperativo\nList&lt;Integer&gt; duplicados = new ArrayList&lt;&gt;();\nfor(Integer n : numeros) {\n    if(n % 2 == 0) {\n        duplicados.add(n * 2);\n    }\n}\n\n// Ejemplo de estilo funcional\nList&lt;Integer&gt; duplicados = numeros.stream()\n    .filter(n -&gt; n % 2 == 0)\n    .map(n -&gt; n * 2)\n    .collect(Collectors.toList());\n</code></pre>"},{"location":"index2/","title":"\ud83d\udcbc SIMULACRO ENTREVISTA JAVA - EXTENDIDO","text":""},{"location":"index2/#seccion-1-fundamentos-de-poo","title":"\ud83d\udd39 Secci\u00f3n 1: Fundamentos de POO","text":""},{"location":"index2/#pregunta-1","title":"\u2753 Pregunta 1:","text":"<p>\u00bfQu\u00e9 es programaci\u00f3n orientada a objetos?</p>"},{"location":"index2/#respuesta","title":"\u2705 Respuesta:","text":"<p>La Programaci\u00f3n Orientada a Objetos (POO) es un paradigma de programaci\u00f3n que organiza el c\u00f3digo en objetos que representan entidades del mundo real. Estos objetos contienen datos (atributos) y comportamientos (m\u00e9todos). La POO permite crear software m\u00e1s modular, reutilizable y mantenible mediante conceptos como encapsulamiento, herencia, polimorfismo y abstracci\u00f3n.</p>"},{"location":"index2/#pregunta-2","title":"\u2753 Pregunta 2:","text":"<p>\u00bfQu\u00e9 es una clase y qu\u00e9 es un objeto? \u00bfCu\u00e1l es la diferencia?</p>"},{"location":"index2/#respuesta_1","title":"\u2705 Respuesta:","text":"<ul> <li>Clase: Es un molde o plantilla que define la estructura y comportamiento de los objetos. Contiene atributos y m\u00e9todos.</li> <li>Objeto: Es una instancia concreta de una clase. Es la materializaci\u00f3n de la clase en memoria.</li> </ul> <p>Diferencia: La clase es el dise\u00f1o abstracto, el objeto es la realidad concreta. Por ejemplo, <code>Coche</code> es una clase, mientras que <code>miCoche = new Coche()</code> es un objeto espec\u00edfico.</p> <pre><code>// Clase\nclass Coche {\n    String marca;\n    void acelerar() { }\n}\n\n// Objeto\nCoche miCoche = new Coche();\n</code></pre>"},{"location":"index2/#pregunta-3","title":"\u2753 Pregunta 3:","text":"<p>\u00bfCu\u00e1les son los 4 pilares de la programaci\u00f3n orientada a objetos?</p>"},{"location":"index2/#respuesta_2","title":"\u2705 Respuesta:","text":"<p>1. Herencia: Permite que una clase herede atributos y m\u00e9todos de otra clase padre. <pre><code>class Animal {\n    void comer() { System.out.println(\"Comiendo...\"); }\n}\n\nclass Perro extends Animal {\n    void ladrar() { System.out.println(\"Guau!\"); }\n}\n</code></pre></p> <p>2. Polimorfismo: Capacidad de un objeto de tomar m\u00faltiples formas. Un mismo m\u00e9todo puede comportarse diferente seg\u00fan el objeto. <pre><code>class Animal {\n    void hacerSonido() { }\n}\n\nclass Perro extends Animal {\n    void hacerSonido() { System.out.println(\"Guau\"); }\n}\n\nclass Gato extends Animal {\n    void hacerSonido() { System.out.println(\"Miau\"); }\n}\n\nAnimal miAnimal = new Perro();\nmiAnimal.hacerSonido(); // Imprime \"Guau\"\n</code></pre></p> <p>3. Abstracci\u00f3n: Oculta los detalles complejos y muestra solo lo esencial. <pre><code>abstract class FiguraGeometrica {\n    abstract double calcularArea();\n}\n\nclass Circulo extends FiguraGeometrica {\n    double radio;\n    double calcularArea() {\n        return Math.PI * radio * radio;\n    }\n}\n</code></pre></p> <p>4. Encapsulamiento: Oculta los datos internos y solo permite el acceso mediante m\u00e9todos p\u00fablicos (getters/setters). <pre><code>class CuentaBancaria {\n    private double saldo;\n\n    public double getSaldo() { return saldo; }\n    public void depositar(double monto) { \n        if(monto &gt; 0) saldo += monto; \n    }\n}\n</code></pre></p>"},{"location":"index2/#seccion-2-modificadores-y-palabras-reservadas","title":"\ud83d\udd39 Secci\u00f3n 2: Modificadores y Palabras Reservadas","text":""},{"location":"index2/#pregunta-4","title":"\u2753 Pregunta 4:","text":"<p>\u00bfCu\u00e1les son los modificadores de acceso en Java?</p>"},{"location":"index2/#respuesta_3","title":"\u2705 Respuesta:","text":"<ul> <li><code>public</code>: Accesible desde cualquier clase.</li> <li><code>private</code>: Solo accesible dentro de la misma clase.</li> <li><code>protected</code>: Accesible en el mismo paquete y en clases hijas.</li> <li><code>default</code> (sin modificador): Accesible solo en el mismo paquete.</li> <li><code>static</code>: Pertenece a la clase, no a instancias espec\u00edficas.</li> </ul> <pre><code>public class Ejemplo {\n    public int publico;        // Acceso desde cualquier lugar\n    private int privado;       // Solo dentro de esta clase\n    protected int protegido;   // Mismo paquete y subclases\n    int porDefecto;           // Solo mismo paquete\n    static int estatico;      // Pertenece a la clase\n}\n</code></pre>"},{"location":"index2/#pregunta-5","title":"\u2753 Pregunta 5:","text":"<p>\u00bfCu\u00e1les son algunas palabras reservadas importantes de Java?</p>"},{"location":"index2/#respuesta_4","title":"\u2705 Respuesta:","text":"<ul> <li><code>null</code>: Representa una referencia nula (sin objeto).</li> <li><code>char</code>: Tipo de dato para caracteres.</li> <li><code>final</code>: Impide modificaci\u00f3n de variables, sobrescritura de m\u00e9todos o herencia de clases.</li> <li><code>extends</code>: Indica herencia de clases.</li> <li><code>implements</code>: Implementa interfaces.</li> <li><code>try</code>: Bloque para manejo de excepciones.</li> <li><code>void</code>: Indica que un m\u00e9todo no retorna valor.</li> <li><code>throw</code>: Lanza una excepci\u00f3n manualmente.</li> </ul> <pre><code>public final class Constantes {\n    public static final int MAX = 100;\n}\n\ntry {\n    // c\u00f3digo\n} catch (Exception e) {\n    throw new RuntimeException(\"Error\");\n}\n</code></pre>"},{"location":"index2/#seccion-3-programacion-funcional","title":"\ud83d\udd39 Secci\u00f3n 3: Programaci\u00f3n Funcional","text":""},{"location":"index2/#pregunta-6","title":"\u2753 Pregunta 6:","text":"<p>\u00bfQu\u00e9 es programaci\u00f3n funcional y qu\u00e9 son las funciones lambda?</p>"},{"location":"index2/#respuesta_5","title":"\u2705 Respuesta:","text":"<p>Programaci\u00f3n Funcional: Es un paradigma que trata la computaci\u00f3n como evaluaci\u00f3n de funciones matem\u00e1ticas, evitando estados mutables y efectos secundarios.</p> <p>Funciones Lambda: Son funciones an\u00f3nimas (sin nombre) que permiten escribir c\u00f3digo m\u00e1s conciso. Introducidas en Java 8.</p> <pre><code>// Lambda simple\n(parametros) -&gt; expresion\n\n// Ejemplo 1: Sin par\u00e1metros\n() -&gt; System.out.println(\"Hola\")\n\n// Ejemplo 2: Un par\u00e1metro\nx -&gt; x * x\n\n// Ejemplo 3: M\u00faltiples par\u00e1metros\n(a, b) -&gt; a + b\n\n// Ejemplo 4: Con bloque\n(x) -&gt; {\n    int resultado = x * 2;\n    return resultado;\n}\n</code></pre> <p>Stream API: Permite procesar colecciones de forma funcional.</p> <pre><code>List&lt;Integer&gt; numeros = Arrays.asList(1, 2, 3, 4, 5);\n\n// Filtrar n\u00fameros pares y multiplicar por 2\nList&lt;Integer&gt; resultado = numeros.stream()\n    .filter(n -&gt; n % 2 == 0)\n    .map(n -&gt; n * 2)\n    .collect(Collectors.toList());\n\n// Suma de todos los elementos\nint suma = numeros.stream()\n    .reduce(0, (a, b) -&gt; a + b);\n</code></pre>"},{"location":"index2/#seccion-4-archivos-hilos-y-excepciones","title":"\ud83d\udd39 Secci\u00f3n 4: Archivos, Hilos y Excepciones","text":""},{"location":"index2/#pregunta-7","title":"\u2753 Pregunta 7:","text":"<p>\u00bfQu\u00e9 librer\u00edas conoces para consumo de archivos?</p>"},{"location":"index2/#respuesta_6","title":"\u2705 Respuesta:","text":"<ul> <li><code>java.nio.file</code> (Files, Paths): API moderna para manejo de archivos.</li> <li><code>java.io</code> (FileReader, BufferedReader, FileWriter): API cl\u00e1sica.</li> <li>Apache Commons IO: Librer\u00eda externa con utilidades adicionales.</li> <li>Jackson / Gson: Para archivos JSON.</li> <li>Apache POI: Para archivos Excel.</li> </ul> <pre><code>// Leer archivo con java.nio\nList&lt;String&gt; lineas = Files.readAllLines(Paths.get(\"archivo.txt\"));\n\n// Escribir archivo\nFiles.write(Paths.get(\"salida.txt\"), lineas);\n\n// Leer archivo grande l\u00ednea por l\u00ednea\ntry (Stream&lt;String&gt; stream = Files.lines(Paths.get(\"archivo.txt\"))) {\n    stream.forEach(System.out::println);\n}\n</code></pre>"},{"location":"index2/#pregunta-8","title":"\u2753 Pregunta 8:","text":"<p>\u00bfHa trabajado con hilos? Explique qu\u00e9 son hilos y su diferencia con procesos.</p>"},{"location":"index2/#respuesta_7","title":"\u2705 Respuesta:","text":"<p>Hilo (Thread): Es la unidad m\u00e1s peque\u00f1a de ejecuci\u00f3n dentro de un proceso. Permite ejecutar m\u00faltiples tareas concurrentemente dentro de una aplicaci\u00f3n.</p> <p>Proceso: Es una instancia de un programa en ejecuci\u00f3n con su propio espacio de memoria.</p> <p>Diferencias:</p> <ul> <li>Los hilos comparten memoria dentro del mismo proceso, los procesos tienen memoria separada.</li> <li>Los hilos son m\u00e1s ligeros y r\u00e1pidos de crear.</li> <li>La comunicaci\u00f3n entre hilos es m\u00e1s r\u00e1pida que entre procesos.</li> </ul> <pre><code>// Crear hilo extendiendo Thread\nclass MiHilo extends Thread {\n    public void run() {\n        System.out.println(\"Ejecutando en hilo: \" + getName());\n    }\n}\n\n// Crear hilo implementando Runnable\nclass MiTarea implements Runnable {\n    public void run() {\n        System.out.println(\"Ejecutando tarea\");\n    }\n}\n\n// Uso\nMiHilo hilo1 = new MiHilo();\nhilo1.start();\n\nThread hilo2 = new Thread(new MiTarea());\nhilo2.start();\n\n// Con lambda\nThread hilo3 = new Thread(() -&gt; {\n    System.out.println(\"Hilo con lambda\");\n});\nhilo3.start();\n</code></pre>"},{"location":"index2/#pregunta-9","title":"\u2753 Pregunta 9:","text":"<p>\u00bfQu\u00e9 excepciones conoces en Java?</p>"},{"location":"index2/#respuesta_8","title":"\u2705 Respuesta:","text":"<p>Excepciones comunes:</p> <ul> <li><code>NullPointerException</code>: Se accede a un objeto que es <code>null</code>.</li> <li><code>ArithmeticException</code>: Error aritm\u00e9tico como divisi\u00f3n por cero.</li> <li><code>IllegalAccessException</code>: Intento de acceder a un miembro privado.</li> <li><code>JPAException</code>: Errores relacionados con persistencia JPA.</li> <li><code>IOException</code>: Errores de entrada/salida.</li> <li><code>SQLException</code>: Errores en operaciones de base de datos.</li> <li><code>NumberFormatException</code>: Error al convertir String a n\u00famero.</li> </ul> <pre><code>try {\n    String texto = null;\n    texto.length(); // NullPointerException\n\n    int division = 10 / 0; // ArithmeticException\n\n    int numero = Integer.parseInt(\"abc\"); // NumberFormatException\n\n} catch (NullPointerException e) {\n    System.out.println(\"Objeto nulo detectado\");\n} catch (ArithmeticException e) {\n    System.out.println(\"Error en operaci\u00f3n matem\u00e1tica\");\n} catch (Exception e) {\n    System.out.println(\"Error general: \" + e.getMessage());\n} finally {\n    System.out.println(\"Siempre se ejecuta\");\n}\n</code></pre>"},{"location":"index2/#seccion-5-servicios-rest-y-spring","title":"\ud83d\udd39 Secci\u00f3n 5: Servicios REST y Spring","text":""},{"location":"index2/#pregunta-10","title":"\u2753 Pregunta 10:","text":"<p>\u00bfQu\u00e9 son servicios REST?</p>"},{"location":"index2/#respuesta_9","title":"\u2705 Respuesta:","text":"<p>REST (Representational State Transfer) es un estilo arquitect\u00f3nico para servicios web que permite acceder a recursos mediante HTTP. Utiliza los m\u00e9todos est\u00e1ndar:</p> <ul> <li>GET: Obtener recursos</li> <li>POST: Crear recursos</li> <li>PUT: Actualizar recursos completos</li> <li>PATCH: Actualizar recursos parcialmente</li> <li>DELETE: Eliminar recursos</li> </ul> <pre><code>@RestController\n@RequestMapping(\"/api/usuarios\")\npublic class UsuarioController {\n\n    @GetMapping\n    public List&lt;Usuario&gt; obtenerTodos() { }\n\n    @GetMapping(\"/{id}\")\n    public Usuario obtenerPorId(@PathVariable Long id) { }\n\n    @PostMapping\n    public Usuario crear(@RequestBody Usuario usuario) { }\n\n    @PutMapping(\"/{id}\")\n    public Usuario actualizar(@PathVariable Long id, @RequestBody Usuario usuario) { }\n\n    @DeleteMapping(\"/{id}\")\n    public void eliminar(@PathVariable Long id) { }\n}\n</code></pre>"},{"location":"index2/#pregunta-11","title":"\u2753 Pregunta 11:","text":"<p>\u00bfQu\u00e9 c\u00f3digos HTTP generan los servicios como respuesta?</p>"},{"location":"index2/#respuesta_10","title":"\u2705 Respuesta:","text":"<p>C\u00f3digos 2xx (\u00c9xito):</p> <ul> <li>200 OK: Solicitud exitosa</li> <li>201 Created: Recurso creado exitosamente</li> <li>204 No Content: \u00c9xito sin contenido de respuesta</li> </ul> <p>C\u00f3digos 3xx (Redirecci\u00f3n):</p> <ul> <li>301 Moved Permanently: Recurso movido permanentemente</li> <li>304 Not Modified: Recurso no modificado desde \u00faltima solicitud</li> </ul> <p>C\u00f3digos 4xx (Error del cliente):</p> <ul> <li>400 Bad Request: Solicitud mal formada</li> <li>401 Unauthorized: No autenticado</li> <li>403 Forbidden: No autorizado</li> <li>404 Not Found: Recurso no encontrado</li> <li>409 Conflict: Conflicto con el estado actual</li> </ul> <p>C\u00f3digos 5xx (Error del servidor):</p> <ul> <li>500 Internal Server Error: Error interno del servidor</li> <li>502 Bad Gateway: Error en gateway</li> <li>503 Service Unavailable: Servicio no disponible</li> </ul>"},{"location":"index2/#pregunta-12","title":"\u2753 Pregunta 12:","text":"<p>\u00bfQu\u00e9 es Spring y qu\u00e9 es Spring Boot?</p>"},{"location":"index2/#respuesta_11","title":"\u2705 Respuesta:","text":"<p>Spring: Es un framework de Java para desarrollo de aplicaciones empresariales. Proporciona inversi\u00f3n de control (IoC) e inyecci\u00f3n de dependencias.</p> <p>Spring Boot: Es una extensi\u00f3n de Spring que simplifica la configuraci\u00f3n y el desarrollo. Permite crear aplicaciones stand-alone con configuraci\u00f3n m\u00ednima, servidor embebido y dependencias auto-configuradas.</p> <p>Diferencias:</p> <ul> <li>Spring requiere mucha configuraci\u00f3n XML o Java.</li> <li>Spring Boot tiene configuraci\u00f3n autom\u00e1tica y opiniones por defecto.</li> <li>Spring Boot incluye servidor embebido (Tomcat, Jetty).</li> <li>Spring Boot facilita el arranque r\u00e1pido de proyectos.</li> </ul>"},{"location":"index2/#pregunta-13","title":"\u2753 Pregunta 13:","text":"<p>\u00bfPara qu\u00e9 sirven estas anotaciones b\u00e1sicas de Spring?</p>"},{"location":"index2/#respuesta_12","title":"\u2705 Respuesta:","text":"<ul> <li> <p><code>@Entity</code>: Marca una clase como entidad JPA para mapeo con base de datos.</p> </li> <li> <p><code>@Repository</code>: Indica que la clase es un repositorio (capa de acceso a datos). Maneja excepciones de persistencia.</p> </li> <li> <p><code>@Service</code>: Marca la clase como servicio (l\u00f3gica de negocio).</p> </li> <li> <p><code>@Controller</code>: Define un controlador MVC que retorna vistas.</p> </li> <li> <p><code>@RestController</code>: Combinaci\u00f3n de <code>@Controller</code> + <code>@ResponseBody</code>. Retorna datos en JSON/XML directamente.</p> </li> </ul> <p>Diferencia @Controller vs @RestController: <pre><code>@Controller\npublic class VistaController {\n    @GetMapping(\"/pagina\")\n    public String mostrarPagina() {\n        return \"vista\"; // Retorna nombre de vista HTML\n    }\n}\n\n@RestController\npublic class ApiController {\n    @GetMapping(\"/datos\")\n    public Usuario obtenerDatos() {\n        return new Usuario(); // Retorna JSON directamente\n    }\n}\n</code></pre></p> <ul> <li><code>@RequestMapping</code>: Define la ruta base del controlador o m\u00e9todo espec\u00edfico.</li> </ul> <pre><code>@RestController\n@RequestMapping(\"/api/productos\")\npublic class ProductoController {\n\n    @GetMapping // GET /api/productos\n    public List&lt;Producto&gt; listar() { }\n\n    @PostMapping // POST /api/productos\n    public Producto crear(@RequestBody Producto producto) { }\n}\n</code></pre>"},{"location":"index2/#pregunta-14","title":"\u2753 Pregunta 14:","text":"<p>\u00bfPara qu\u00e9 sirven las palabras reservadas <code>implements</code> y <code>extends</code>?</p>"},{"location":"index2/#respuesta_13","title":"\u2705 Respuesta:","text":"<ul> <li> <p><code>extends</code>: Se usa para herencia de clases. Una clase puede extender solo una clase padre.</p> </li> <li> <p><code>implements</code>: Se usa para implementar interfaces. Una clase puede implementar m\u00faltiples interfaces.</p> </li> </ul> <pre><code>// extends - Herencia\nclass Animal {\n    void comer() { }\n}\n\nclass Perro extends Animal {\n    void ladrar() { }\n}\n\n// implements - Implementaci\u00f3n de interfaces\ninterface Volador {\n    void volar();\n}\n\ninterface Nadador {\n    void nadar();\n}\n\nclass Pato implements Volador, Nadador {\n    public void volar() { }\n    public void nadar() { }\n}\n\n// Combinaci\u00f3n\nclass PatoDomestico extends Ave implements Volador, Nadador {\n    // Hereda de Ave e implementa dos interfaces\n}\n</code></pre>"},{"location":"index2/#pregunta-15","title":"\u2753 Pregunta 15:","text":"<p>\u00bfQu\u00e9 diferencia hay entre <code>@Component</code> y <code>@Bean</code>?</p>"},{"location":"index2/#respuesta_14","title":"\u2705 Respuesta:","text":"<ul> <li> <p><code>@Component</code>: Se coloca sobre una clase para que Spring la detecte autom\u00e1ticamente y la registre como bean. Es un estereotipo gen\u00e9rico.</p> </li> <li> <p><code>@Bean</code>: Se coloca sobre un m\u00e9todo en una clase de configuraci\u00f3n (<code>@Configuration</code>) para registrar manualmente el objeto que retorna como bean.</p> </li> </ul> <p>Uso: <pre><code>// @Component - Auto-detecci\u00f3n\n@Component\npublic class MiServicio {\n    public void hacer() { }\n}\n\n// @Bean - Configuraci\u00f3n manual\n@Configuration\npublic class AppConfig {\n\n    @Bean\n    public MiServicio miServicio() {\n        return new MiServicio();\n    }\n\n    @Bean\n    public ObjectMapper objectMapper() {\n        return new ObjectMapper(); // Para librer\u00edas externas\n    }\n}\n</code></pre></p> <p>Cu\u00e1ndo usar cada uno:</p> <ul> <li><code>@Component</code>: Para clases propias donde puedes modificar el c\u00f3digo.</li> <li><code>@Bean</code>: Para librer\u00edas externas o cuando necesitas configuraci\u00f3n especial.</li> </ul>"},{"location":"index2/#seccion-6-seguridad","title":"\ud83d\udd39 Secci\u00f3n 6: Seguridad","text":""},{"location":"index2/#pregunta-16","title":"\u2753 Pregunta 16:","text":"<p>\u00bfQu\u00e9 es JWT (JSON Web Token) y c\u00f3mo se implementa?</p>"},{"location":"index2/#respuesta_15","title":"\u2705 Respuesta:","text":"<p>JWT: Es un est\u00e1ndar para transmitir informaci\u00f3n de forma segura entre partes como un objeto JSON. Se usa principalmente para autenticaci\u00f3n y autorizaci\u00f3n.</p> <p>Estructura (xxx.yyy.zzz):</p> <ul> <li>Header: Tipo de token y algoritmo de encriptaci\u00f3n.</li> <li>Payload: Datos del usuario (claims).</li> <li>Signature: Firma para verificar integridad.</li> </ul> <pre><code>// Generar JWT\nString jwt = Jwts.builder()\n    .setSubject(usuario.getUsername())\n    .setIssuedAt(new Date())\n    .setExpiration(new Date(System.currentTimeMillis() + 86400000))\n    .signWith(SignatureAlgorithm.HS512, \"secretKey\")\n    .compact();\n\n// Validar JWT\nClaims claims = Jwts.parser()\n    .setSigningKey(\"secretKey\")\n    .parseClaimsJws(jwt)\n    .getBody();\n\nString username = claims.getSubject();\n</code></pre> <p>Flujo de implementaci\u00f3n:</p> <ol> <li>Usuario se autentica con credenciales.</li> <li>Servidor genera JWT y lo env\u00eda al cliente.</li> <li>Cliente incluye JWT en cada petici\u00f3n (header Authorization).</li> <li>Servidor valida JWT antes de procesar la petici\u00f3n.</li> </ol>"},{"location":"index2/#pregunta-17","title":"\u2753 Pregunta 17:","text":"<p>\u00bfQu\u00e9 es OAuth y OAuth2? \u00bfCu\u00e1les son sus diferencias?</p>"},{"location":"index2/#respuesta_16","title":"\u2705 Respuesta:","text":"<p>OAuth: Protocolo de autorizaci\u00f3n que permite a aplicaciones obtener acceso limitado a cuentas de usuario sin exponer contrase\u00f1as.</p> <p>OAuth2: Versi\u00f3n mejorada y m\u00e1s simple de OAuth. Es el est\u00e1ndar actual.</p> <p>Diferencias OAuth vs OAuth2:</p> <ul> <li>OAuth2 es m\u00e1s simple de implementar.</li> <li>OAuth2 tiene mejor soporte para aplicaciones m\u00f3viles.</li> <li>OAuth2 separa roles (Resource Owner, Client, Authorization Server, Resource Server).</li> <li>OAuth tiene firmas criptogr\u00e1ficas complejas; OAuth2 usa HTTPS.</li> </ul> <p>Flujo OAuth2:</p> <ol> <li>Usuario solicita acceso a recurso.</li> <li>Aplicaci\u00f3n redirige a servidor de autorizaci\u00f3n.</li> <li>Usuario se autentica y otorga permisos.</li> <li>Servidor retorna c\u00f3digo de autorizaci\u00f3n.</li> <li>Aplicaci\u00f3n intercambia c\u00f3digo por access token.</li> <li>Aplicaci\u00f3n usa token para acceder a recursos protegidos.</li> </ol>"},{"location":"index2/#pregunta-18","title":"\u2753 Pregunta 18:","text":"<p>\u00bfHas consumido servicios REST/SOAP? \u00bfDe qu\u00e9 formas lo haces?</p>"},{"location":"index2/#respuesta_17","title":"\u2705 Respuesta:","text":"<p>REST (JSON): <pre><code>// Con RestTemplate (Spring)\nRestTemplate restTemplate = new RestTemplate();\nUsuario usuario = restTemplate.getForObject(\"http://api.com/usuarios/1\", Usuario.class);\n\n// Con WebClient (Spring WebFlux) - Reactivo\nWebClient client = WebClient.create(\"http://api.com\");\nUsuario usuario = client.get()\n    .uri(\"/usuarios/1\")\n    .retrieve()\n    .bodyToMono(Usuario.class)\n    .block();\n\n// Con HttpClient (Java 11+)\nHttpClient client = HttpClient.newHttpClient();\nHttpRequest request = HttpRequest.newBuilder()\n    .uri(URI.create(\"http://api.com/usuarios\"))\n    .GET()\n    .build();\nHttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());\n</code></pre></p> <p>SOAP (WSDL/XML): <pre><code>// Usando clientes generados desde WSDL\nURL wsdlUrl = new URL(\"http://servidor.com/servicio?wsdl\");\nQName serviceName = new QName(\"http://ejemplo.com/\", \"MiServicio\");\nService service = Service.create(wsdlUrl, serviceName);\nMiServicioPort port = service.getPort(MiServicioPort.class);\nRespuesta resultado = port.miMetodo(parametros);\n</code></pre></p>"},{"location":"index2/#pregunta-19","title":"\u2753 Pregunta 19:","text":"<p>\u00bfQu\u00e9 es inyecci\u00f3n de dependencias y c\u00f3mo se implementa en Spring?</p>"},{"location":"index2/#respuesta_18","title":"\u2705 Respuesta:","text":"<p>Inyecci\u00f3n de Dependencias (DI): Es un patr\u00f3n de dise\u00f1o donde los objetos reciben sus dependencias desde el exterior en lugar de crearlas ellos mismos. Promueve bajo acoplamiento y facilita testing.</p> <p>Formas de inyecci\u00f3n en Spring:</p> <pre><code>@Service\npublic class UsuarioService {\n\n    // 1. Inyecci\u00f3n por constructor (recomendada)\n    private final UsuarioRepository repository;\n\n    @Autowired // Opcional desde Spring 4.3\n    public UsuarioService(UsuarioRepository repository) {\n        this.repository = repository;\n    }\n\n    // 2. Inyecci\u00f3n por setter\n    private EmailService emailService;\n\n    @Autowired\n    public void setEmailService(EmailService emailService) {\n        this.emailService = emailService;\n    }\n\n    // 3. Inyecci\u00f3n por campo (no recomendada)\n    @Autowired\n    private NotificacionService notificacionService;\n}\n</code></pre> <p>Ventajas:</p> <ul> <li>Facilita pruebas unitarias (puedes inyectar mocks).</li> <li>Reduce acoplamiento entre clases.</li> <li>Mayor flexibilidad y mantenibilidad.</li> </ul>"},{"location":"index2/#seccion-7-solid-y-arquitecturas","title":"\ud83d\udd39 Secci\u00f3n 7: SOLID y Arquitecturas","text":""},{"location":"index2/#pregunta-20","title":"\u2753 Pregunta 20:","text":"<p>PREGUNTA CLAVE: \u00bfQu\u00e9 es SOLID y c\u00f3mo se implementa?</p>"},{"location":"index2/#respuesta_19","title":"\u2705 Respuesta:","text":"<p>SOLID son 5 principios de dise\u00f1o orientado a objetos para crear software mantenible y escalable:</p> <p>S - Single Responsibility Principle (Responsabilidad \u00danica) Cada clase debe tener una \u00fanica raz\u00f3n para cambiar. <pre><code>// \u274c Mal\nclass Usuario {\n    void guardar() { } // Persistencia\n    void enviarEmail() { } // Notificaci\u00f3n\n}\n\n// \u2705 Bien\nclass Usuario { }\nclass UsuarioRepository {\n    void guardar(Usuario u) { }\n}\nclass EmailService {\n    void enviar(String email) { }\n}\n</code></pre></p> <p>O - Open/Closed Principle (Abierto/Cerrado) Abierto para extensi\u00f3n, cerrado para modificaci\u00f3n. <pre><code>// \u2705 Extensible sin modificar\ninterface FormaPago {\n    void pagar(double monto);\n}\n\nclass PagoTarjeta implements FormaPago {\n    public void pagar(double monto) { }\n}\n\nclass PagoPayPal implements FormaPago {\n    public void pagar(double monto) { }\n}\n</code></pre></p> <p>L - Liskov Substitution Principle (Sustituci\u00f3n de Liskov) Las subclases deben poder sustituir a sus clases base sin alterar el funcionamiento. <pre><code>class Ave {\n    void mover() { }\n}\n\nclass Aguila extends Ave {\n    void mover() { /* volar */ }\n}\n\nclass Pinguino extends Ave {\n    void mover() { /* nadar/caminar */ }\n}\n</code></pre></p> <p>I - Interface Segregation Principle (Segregaci\u00f3n de Interfaces) Es mejor tener varias interfaces espec\u00edficas que una general. <pre><code>// \u274c Mal\ninterface Trabajador {\n    void trabajar();\n    void comer();\n    void dormir();\n}\n\n// \u2705 Bien\ninterface Trabajable {\n    void trabajar();\n}\n\ninterface Alimentable {\n    void comer();\n}\n</code></pre></p> <p>D - Dependency Inversion Principle (Inversi\u00f3n de Dependencias) Depender de abstracciones, no de implementaciones concretas. <pre><code>// \u2705 Depende de interfaz, no de clase concreta\ninterface NotificacionService {\n    void enviar(String mensaje);\n}\n\nclass EmailNotificacion implements NotificacionService {\n    public void enviar(String mensaje) { }\n}\n\nclass UsuarioController {\n    private NotificacionService servicio;\n\n    public UsuarioController(NotificacionService servicio) {\n        this.servicio = servicio;\n    }\n}\n</code></pre></p>"},{"location":"index2/#pregunta-21","title":"\u2753 Pregunta 21:","text":"<p>\u00bfQu\u00e9 diferencias hay entre arquitectura monol\u00edtica y microservicios?</p>"},{"location":"index2/#respuesta_20","title":"\u2705 Respuesta:","text":"<p>Arquitectura Monol\u00edtica:</p> <ul> <li>Aplicaci\u00f3n \u00fanica y completa.</li> <li>Todo est\u00e1 en un mismo c\u00f3digo base.</li> <li>Se despliega como una unidad.</li> </ul> <p>Ventajas:</p> <ul> <li>Simple de desarrollar y desplegar.</li> <li>F\u00e1cil de testear.</li> <li>Menos complejidad operacional.</li> </ul> <p>Desventajas:</p> <ul> <li>Dif\u00edcil de escalar.</li> <li>Acoplamiento fuerte.</li> <li>Despliegues arriesgados (todo o nada).</li> <li>Tecnolog\u00eda \u00fanica.</li> </ul> <p>Microservicios:</p> <ul> <li>Aplicaci\u00f3n dividida en servicios peque\u00f1os e independientes.</li> <li>Cada servicio se despliega independientemente.</li> <li>Comunicaci\u00f3n mediante APIs.</li> </ul> <p>Ventajas:</p> <ul> <li>Escalabilidad independiente.</li> <li>Bajo acoplamiento.</li> <li>Flexibilidad tecnol\u00f3gica.</li> <li>Equipos independientes.</li> <li>Despliegues m\u00e1s seguros.</li> </ul> <p>Desventajas:</p> <ul> <li>Mayor complejidad operacional.</li> <li>Requiere DevOps maduro.</li> <li>Debugging m\u00e1s complejo.</li> <li>Latencia de red.</li> </ul>"},{"location":"index2/#pregunta-22","title":"\u2753 Pregunta 22:","text":"<p>\u00bfQu\u00e9 es arquitectura hexagonal?</p>"},{"location":"index2/#respuesta_21","title":"\u2705 Respuesta:","text":"<p>Arquitectura Hexagonal (Ports and Adapters): Patr\u00f3n que separa la l\u00f3gica de negocio de los detalles de infraestructura (BD, APIs, UI).</p> <p>Capas: - Dominio (Centro): L\u00f3gica de negocio pura, sin dependencias externas. - Puertos: Interfaces que definen contratos. - Adaptadores: Implementaciones concretas (BD, REST, etc.).</p> <pre><code>Estructura:\n\u251c\u2500\u2500 domain/\n\u2502   \u251c\u2500\u2500 model/\n\u2502   \u2502   \u2514\u2500\u2500 Usuario.java\n\u2502   \u251c\u2500\u2500 port/\n\u2502   \u2502   \u251c\u2500\u2500 input/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 CrearUsuarioUseCase.java\n\u2502   \u2502   \u2514\u2500\u2500 output/\n\u2502   \u2502       \u2514\u2500\u2500 UsuarioRepository.java\n\u2502   \u2514\u2500\u2500 service/\n\u2502       \u2514\u2500\u2500 UsuarioService.java\n\u2514\u2500\u2500 adapter/\n    \u251c\u2500\u2500 input/\n    \u2502   \u2514\u2500\u2500 rest/\n    \u2502       \u2514\u2500\u2500 UsuarioController.java\n    \u2514\u2500\u2500 output/\n        \u2514\u2500\u2500 persistence/\n            \u2514\u2500\u2500 UsuarioJpaAdapter.java\n</code></pre> <p>Ventajas:</p> <ul> <li>L\u00f3gica de negocio independiente.</li> <li>F\u00e1cil de testear.</li> <li>Cambiar tecnolog\u00edas sin afectar el core.</li> </ul>"},{"location":"index2/#pregunta-23","title":"\u2753 Pregunta 23:","text":"<p>\u00bfQu\u00e9 es ACID?</p>"},{"location":"index2/#respuesta_22","title":"\u2705 Respuesta:","text":"<p>ACID son propiedades que garantizan la confiabilidad de las transacciones en bases de datos:</p> <ul> <li> <p>A - Atomicity (Atomicidad): La transacci\u00f3n se completa totalmente o no se completa en absoluto (todo o nada).</p> </li> <li> <p>C - Consistency (Consistencia): La transacci\u00f3n lleva la base de datos de un estado v\u00e1lido a otro estado v\u00e1lido.</p> </li> <li> <p>I - Isolation (Aislamiento): Las transacciones concurrentes no interfieren entre s\u00ed.</p> </li> <li> <p>D - Durability (Durabilidad): Una vez confirmada, la transacci\u00f3n persiste incluso ante fallos del sistema.</p> </li> </ul> <pre><code>@Transactional\npublic void transferir(Long origen, Long destino, double monto) {\n    Cuenta cuentaOrigen = cuentaRepo.findById(origen);\n    Cuenta cuentaDestino = cuentaRepo.findById(destino);\n\n    cuentaOrigen.debitar(monto);    // Si falla aqu\u00ed\n    cuentaDestino.acreditar(monto); // y no ejecuta esto\n    // Toda la operaci\u00f3n se revierte (rollback)\n}\n</code></pre>"},{"location":"index2/#seccion-8-patrones-de-diseno","title":"\ud83d\udd39 Secci\u00f3n 8: Patrones de Dise\u00f1o","text":""},{"location":"index2/#pregunta-24","title":"\u2753 Pregunta 24:","text":"<p>\u00bfQu\u00e9 es alta cohesi\u00f3n y bajo acoplamiento?</p>"},{"location":"index2/#respuesta_23","title":"\u2705 Respuesta:","text":"<p>Alta Cohesi\u00f3n: Los elementos dentro de un m\u00f3dulo est\u00e1n fuertemente relacionados y tienen un prop\u00f3sito bien definido.</p> <p>Bajo Acoplamiento: Los m\u00f3dulos tienen poca dependencia entre s\u00ed. Los cambios en uno no afectan mucho a otros.</p> <pre><code>// \u274c Baja cohesi\u00f3n (clase hace muchas cosas no relacionadas)\nclass UsuarioManager {\n    void guardarUsuario() { }\n    void enviarEmail() { }\n    void generarReporte() { }\n}\n\n// \u2705 Alta cohesi\u00f3n\nclass UsuarioRepository {\n    void guardar() { }\n    void buscar() { }\n}\n\nclass EmailService {\n    void enviar() { }\n}\n\n// \u274c Alto acoplamiento\nclass Pedido {\n    MySQLDatabase db = new MySQLDatabase(); // Depende de implementaci\u00f3n concreta\n}\n\n// \u2705 Bajo acoplamiento\nclass Pedido {\n    private Database db; // Depende de interfaz\n    public Pedido(Database db) {\n        this.db = db;\n    }\n}\n</code></pre>"},{"location":"index2/#pregunta-25","title":"\u2753 Pregunta 25:","text":"<p>\u00bfConoces alg\u00fan patr\u00f3n de dise\u00f1o? Explica DTO, Adapter, Factory, Builder y Abstract Factory.</p>"},{"location":"index2/#respuesta_24","title":"\u2705 Respuesta:","text":"<p>Patrones Creacionales: C\u00f3mo se crean objetos.</p> <p>1. Factory (F\u00e1brica) Crea objetos sin exponer la l\u00f3gica de creaci\u00f3n. <pre><code>interface Vehiculo {\n    void conducir();\n}\n\nclass Coche implements Vehiculo {\n    public void conducir() { }\n}\n\nclass Moto implements Vehiculo {\n    public void conducir() { }\n}\n\nclass VehiculoFactory {\n    public static Vehiculo crear(String tipo) {\n        if (tipo.equals(\"coche\")) return new Coche();\n        if (tipo.equals(\"moto\")) return new Moto();\n        return null;\n    }\n}\n</code></pre></p> <p>2. Abstract Factory (F\u00e1brica Abstracta) Crea familias de objetos relacionados. <pre><code>interface FabricaMuebles {\n    Silla crearSilla();\n    Mesa crearMesa();\n}\n\nclass FabricaModerna implements FabricaMuebles {\n    public Silla crearSilla() { return new SillaModerna(); }\n    public Mesa crearMesa() { return new MesaModerna(); }\n}\n</code></pre></p> <p>3. Builder (Constructor) Construye objetos complejos paso a paso. <pre><code>class Usuario {\n    private String nombre;\n    private String email;\n    private int edad;\n\n    private Usuario(Builder builder) {\n        this.nombre = builder.nombre;\n        this.email = builder.email;\n        this.edad = builder.edad;\n    }\n\n    static class Builder {\n        private String nombre;\n        private String email;\n        private int edad;\n\n        public Builder nombre(String nombre) {\n            this.nombre = nombre;\n            return this;\n        }\n\n        public Builder email(String email) {\n            this.email = email;\n            return this;\n        }\n\n        public Builder edad(int edad) {\n            this.edad = edad;\n            return this;\n        }\n\n        public Usuario build() {\n            return new Usuario(this);\n        }\n    }\n}\n\n// Uso\nUsuario usuario = new Usuario.Builder()\n    .nombre(\"Juan\")\n    .email(\"juan@mail.com\")\n    .edad(25)\n    .build();\n</code></pre></p> <p>Patrones Estructurales: C\u00f3mo se organizan las clases.</p> <p>4. Adapter (Adaptador) Permite que interfaces incompatibles trabajen juntas. <pre><code>// Interfaz existente\ninterface MediaPlayer {\n    void play(String tipo, String archivo);\n}\n\n// Interfaz avanzada incompatible\ninterface AdvancedPlayer {\n    void playVlc(String archivo);\n    void playMp4(String archivo);\n}\n\n// Adapter\nclass MediaAdapter implements MediaPlayer {\n    private AdvancedPlayer advancedPlayer;\n\n    public MediaAdapter(String tipo) {\n        if (tipo.equals(\"vlc\")) {\n            advancedPlayer = new VlcPlayer();\n        } else if (tipo.equals(\"mp4\")) {\n            advancedPlayer = new Mp4Player();\n        }\n    }\n\n    public void play(String tipo, String archivo) {\n        if (tipo.equals(\"vlc\")) {\n            advancedPlayer.playVlc(archivo);\n        } else if (tipo.equals(\"mp4\")) {\n            advancedPlayer.playMp4(archivo);\n        }\n    }\n}\n</code></pre></p> <p>Patrones de Funcionalidad/Comportamiento:</p> <p>5. DTO (Data Transfer Object) Objeto simple para transferir datos entre capas. <pre><code>public class UsuarioDTO {\n    private String nombre;\n    private String email;\n\n    // Getters y setters\n}\n\n// Uso en controlador\n@PostMapping(\"/usuarios\")\npublic ResponseEntity&lt;UsuarioDTO&gt; crear(@RequestBody UsuarioDTO dto) {\n    Usuario usuario = mapper.toEntity(dto);\n    repository.save(usuario);\n    return ResponseEntity.ok(mapper.toDTO(usuario));\n}\n</code></pre></p>"},{"location":"index2/#pregunta-26","title":"\u2753 Pregunta 26:","text":"<p>\u00bfConoces patrones de arquitectura de microservicios?</p>"},{"location":"index2/#respuesta_25","title":"\u2705 Respuesta:","text":"<p>1. Retry (Reintentos) Reintenta operaciones fallidas autom\u00e1ticamente. <pre><code>@Retryable(\n    value = {ServiceException.class},\n    maxAttempts = 3,\n    backoff = @Backoff(delay = 1000)\n)\npublic String llamarServicio() {\n    // Si falla, reintenta 3 veces con 1 segundo de espera\n}\n</code></pre></p> <p>2. Circuit Breaker (Cortocircuito) Previene llamadas a servicios que fallan constantemente. <pre><code>@CircuitBreaker(name = \"servicioExterno\", fallbackMethod = \"fallback\")\npublic String obtenerDatos() {\n    return restTemplate.getForObject(\"http://servicio-externo/api\", String.class);\n}\n\npublic String fallback(Exception e) {\n    return \"Datos en cach\u00e9 o respuesta por defecto\";\n}\n\n// Estados: Cerrado (normal) -&gt; Abierto (falla) -&gt; Semi-abierto (prueba)\n</code></pre></p> <p>3. API Gateway Punto de entrada \u00fanico para todos los microservicios. - Enrutamiento de peticiones. - Autenticaci\u00f3n y autorizaci\u00f3n. - Rate limiting. - Transformaci\u00f3n de respuestas.</p> <p>4. Patr\u00f3n Saga Gestiona transacciones distribuidas entre microservicios.</p> <p>a) Saga Orquestado: Un orquestador central coordina las transacciones. <pre><code>Orquestador\n    \u251c\u2500\u2500&gt; Servicio Pedido (crear)\n    \u251c\u2500\u2500&gt; Servicio Inventario (reservar)\n    \u251c\u2500\u2500&gt; Servicio Pago (cobrar)\n    \u2514\u2500\u2500&gt; Servicio Env\u00edo (programar)\n\nSi falla alguno, ejecuta compensaciones en orden inverso\n</code></pre></p> <p>b) Saga Coreografeado: Cada servicio publica eventos y otros reaccionan. <pre><code>Pedido creado (evento)\n    \u251c\u2500\u2500&gt; Inventario escucha y reserva\n    \u2502    \u2514\u2500\u2500&gt; Inventario reservado (evento)\n    \u2502         \u251c\u2500\u2500&gt; Pago escucha y procesa\n    \u2502         \u2502    \u2514\u2500\u2500&gt; Pago exitoso (evento)\n    \u2502         \u2502         \u2514\u2500\u2500&gt; Env\u00edo escucha y programa\n    \u2502         \u2514\u2500\u2500&gt; Si falla, publica evento de compensaci\u00f3n\n</code></pre></p>"},{"location":"index2/#pregunta-27","title":"\u2753 Pregunta 27:","text":"<p>\u00bfConoces Kafka o RabbitMQ?</p>"},{"location":"index2/#respuesta_26","title":"\u2705 Respuesta:","text":"<p>Ambos son sistemas de mensajer\u00eda de colas para comunicaci\u00f3n as\u00edncrona entre servicios.</p> <p>RabbitMQ: - Message broker tradicional. - Protocolo AMQP. - Garantiza orden y entrega de mensajes. - Mejor para sistemas transaccionales.</p> <p>Apache Kafka: - Plataforma de streaming distribuido. - Alta throughput (millones de mensajes/segundo). - Almacena mensajes en disco (log distribuido). - Mejor para event sourcing y big data.</p> <pre><code>// Kafka Producer (Spring)\n@Service\npublic class KafkaProducer {\n    @Autowired\n    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;\n\n    public void enviarMensaje(String topic, String mensaje) {\n        kafkaTemplate.send(topic, mensaje);\n    }\n}\n\n// Kafka Consumer\n@KafkaListener(topics = \"mi-topic\", groupId = \"mi-grupo\")\npublic void consumir(String mensaje) {\n    System.out.println(\"Recibido: \" + mensaje);\n}\n</code></pre> <p>Casos de uso: - Desacoplamiento de servicios. - Procesamiento as\u00edncrono. - Event-driven architecture. - Logs y m\u00e9tricas centralizados.</p>"},{"location":"index2/#pregunta-28","title":"\u2753 Pregunta 28:","text":"<p>\u00bfC\u00f3mo controlan la concurrencia en Java?</p>"},{"location":"index2/#respuesta_27","title":"\u2705 Respuesta:","text":"<p>1. Synchronized <pre><code>private int contador = 0;\n\npublic synchronized void incrementar() {\n    contador++;\n}\n\n// O sincronizar un bloque\npublic void metodo() {\n    synchronized(this) {\n        // c\u00f3digo cr\u00edtico\n    }\n}\n</code></pre></p> <p>2. Lock (ReentrantLock) <pre><code>private final Lock lock = new ReentrantLock();\n\npublic void metodo() {\n    lock.lock();\n    try {\n        // c\u00f3digo cr\u00edtico\n    } finally {\n        lock.unlock();\n    }\n}\n</code></pre></p> <p>3. Atomic Variables <pre><code>private AtomicInteger contador = new AtomicInteger(0);\n\npublic void incrementar() {\n    contador.incrementAndGet();\n}\n</code></pre></p> <p>4. ThreadLocal <pre><code>private ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; 0);\n\npublic void usar() {\n    threadLocal.set(10);\n    int valor = threadLocal.get();\n}\n</code></pre></p> <p>5. CompletableFuture (Programaci\u00f3n as\u00edncrona) <pre><code>CompletableFuture.supplyAsync(() -&gt; {\n    return \"Resultado\";\n}).thenApply(resultado -&gt; {\n    return resultado + \" procesado\";\n}).thenAccept(System.out::println);\n</code></pre></p>"},{"location":"index2/#seccion-9-devops-e-infraestructura","title":"\ud83d\udd39 Secci\u00f3n 9: DevOps e Infraestructura","text":""},{"location":"index2/#pregunta-29","title":"\u2753 Pregunta 29:","text":"<p>\u00bfSabes qu\u00e9 es CI/CD? \u00bfC\u00f3mo se implementa?</p>"},{"location":"index2/#respuesta_28","title":"\u2705 Respuesta:","text":"<p>CI/CD: Continuous Integration / Continuous Deployment</p> <p>CI (Integraci\u00f3n Continua): - Integrar c\u00f3digo frecuentemente al repositorio. - Ejecutar tests autom\u00e1ticamente. - Detectar errores r\u00e1pidamente.</p> <p>CD (Despliegue Continuo): - Desplegar autom\u00e1ticamente a producci\u00f3n. - Cada cambio que pasa tests se despliega.</p> <p>Implementaci\u00f3n con pipelines: <pre><code># Ejemplo Azure DevOps Pipeline\ntrigger:\n  branches:\n    include:\n      - develop\n      - stage\n      - master\n\nstages:\n  - stage: Build\n    jobs:\n      - job: Compile\n        steps:\n          - task: Maven@3\n            inputs:\n              goals: 'clean package'\n          - task: Docker@2\n            inputs:\n              command: 'build'\n\n  - stage: Test\n    jobs:\n      - job: UnitTests\n        steps:\n          - task: Maven@3\n            inputs:\n              goals: 'test'\n\n  - stage: Deploy\n    condition: eq(variables['Build.SourceBranch'], 'refs/heads/master')\n    jobs:\n      - job: Production\n        steps:\n          - task: Docker@2\n            inputs:\n              command: 'push'\n          - task: Kubernetes@1\n            inputs:\n              command: 'apply'\n</code></pre></p> <p>Ramas est\u00e1ndar: - <code>feature/*</code>: Desarrollo de nuevas funcionalidades. - <code>develop</code>: Integraci\u00f3n de features. - <code>stage</code>: Ambiente de pre-producci\u00f3n. - <code>master/main</code>: Producci\u00f3n.</p>"},{"location":"index2/#pregunta-30","title":"\u2753 Pregunta 30:","text":"<p>\u00bfQu\u00e9 herramientas conoces? Docker, Azure DevOps.</p>"},{"location":"index2/#respuesta_29","title":"\u2705 Respuesta:","text":"<p>Docker: Plataforma de contenedorizaci\u00f3n que empaqueta aplicaciones con sus dependencias.</p> <pre><code># Dockerfile\nFROM openjdk:17-slim\nWORKDIR /app\nCOPY target/mi-app.jar app.jar\nEXPOSE 8080\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]\n</code></pre> <pre><code># docker-compose.yml\nversion: '3.8'\nservices:\n  app:\n    build: .\n    ports:\n      - \"8080:8080\"\n    environment:\n      - SPRING_PROFILES_ACTIVE=prod\n    depends_on:\n      - db\n  db:\n    image: postgres:14\n    environment:\n      POSTGRES_DB: midb\n      POSTGRES_PASSWORD: secret\n</code></pre> <p>Azure DevOps: Plataforma completa de DevOps. - Azure Repos: Control de versiones (Git). - Azure Pipelines: CI/CD automatizado. - Azure Boards: Gesti\u00f3n de trabajo (Kanban, Scrum). - Azure Test Plans: Testing. - Azure Artifacts: Gesti\u00f3n de paquetes.</p>"},{"location":"index2/#pregunta-31","title":"\u2753 Pregunta 31:","text":"<p>\u00bfSabes qu\u00e9 es un cl\u00faster y con qu\u00e9 se administra?</p>"},{"location":"index2/#respuesta_30","title":"\u2705 Respuesta:","text":"<p>Cl\u00faster: Conjunto de servidores (nodos) que trabajan juntos como un sistema \u00fanico para alta disponibilidad y escalabilidad.</p> <p>Kubernetes (K8s): Sistema de orquestaci\u00f3n de contenedores m\u00e1s usado para administrar cl\u00fasteres.</p> <p>Componentes principales: - Pod: Unidad m\u00ednima desplegable (1+ contenedores). - Node: Servidor f\u00edsico o virtual del cl\u00faster. - Deployment: Define el estado deseado de pods. - Service: Expone pods a la red. - Ingress: Gestiona acceso HTTP/HTTPS externo.</p> <pre><code># deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: mi-app\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: mi-app\n  template:\n    metadata:\n      labels:\n        app: mi-app\n    spec:\n      containers:\n      - name: app\n        image: mi-app:1.0\n        ports:\n        - containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: mi-app-service\nspec:\n  selector:\n    app: mi-app\n  ports:\n  - port: 80\n    targetPort: 8080\n  type: LoadBalancer\n</code></pre> <p>Ventajas: - Auto-escalado. - Auto-recuperaci\u00f3n. - Balanceo de carga. - Despliegues sin downtime.</p>"},{"location":"index2/#pregunta-32","title":"\u2753 Pregunta 32:","text":"<p>\u00bfQu\u00e9 servidores conoces? \u00bfQu\u00e9 es nube h\u00edbrida, privada y p\u00fablica?</p>"},{"location":"index2/#respuesta_31","title":"\u2705 Respuesta:","text":"<p>Servidores Linux: - Ubuntu: Distribuci\u00f3n popular, f\u00e1cil de usar, LTS (Long Term Support). - CentOS: Basado en Red Hat, estable para servidores empresariales. - Debian: Muy estable, base de Ubuntu. - Red Hat Enterprise Linux (RHEL): Versi\u00f3n comercial con soporte.</p> <p>Tipos de nube:</p> <p>Nube P\u00fablica: - Infraestructura compartida. - Proveedores: AWS, Azure, Google Cloud. - Pago por uso. - Ventajas: Escalable, sin mantenimiento de hardware.</p> <p>Nube Privada: - Infraestructura dedicada a una organizaci\u00f3n. - Puede estar on-premise o gestionada por proveedor. - Mayor control y seguridad. - Mayor costo.</p> <p>Nube H\u00edbrida: - Combinaci\u00f3n de p\u00fablica y privada. - Datos sensibles en privada, cargas variables en p\u00fablica. - Flexibilidad y optimizaci\u00f3n de costos.</p>"},{"location":"index2/#pregunta-33","title":"\u2753 Pregunta 33:","text":"<p>\u00bfQu\u00e9 servicios de AWS conoces?</p>"},{"location":"index2/#respuesta_32","title":"\u2705 Respuesta:","text":"<p>Computaci\u00f3n: - EC2 (Elastic Compute Cloud): Servidores virtuales. - Lambda: Funciones serverless (sin servidor). - Elastic Beanstalk: Despliegue autom\u00e1tico de aplicaciones.</p> <p>Almacenamiento: - S3 (Simple Storage Service): Almacenamiento de objetos (archivos). - EBS (Elastic Block Store): Discos para EC2.</p> <p>Base de Datos: - RDS: Bases de datos relacionales (MySQL, PostgreSQL). - DynamoDB: Base de datos NoSQL.</p> <p>Red: - API Gateway: Gesti\u00f3n de APIs. - CloudFront: CDN (Content Delivery Network). - VPC: Red privada virtual.</p> <p>Monitoreo: - CloudWatch: Logs y m\u00e9tricas. - CloudTrail: Auditor\u00eda de acciones en AWS.</p> <pre><code>// Ejemplo: Subir archivo a S3\nAmazonS3 s3Client = AmazonS3ClientBuilder.standard()\n    .withRegion(Regions.US_EAST_1)\n    .build();\n\ns3Client.putObject(\n    \"mi-bucket\",\n    \"archivo.txt\",\n    new File(\"ruta/archivo.txt\")\n);\n</code></pre>"},{"location":"index2/#pregunta-34","title":"\u2753 Pregunta 34:","text":"<p>\u00bfC\u00f3mo puedes desplegar continuamente infraestructura? \u00bfConoces Terraform?</p>"},{"location":"index2/#respuesta_33","title":"\u2705 Respuesta:","text":"<p>Terraform: Herramienta de Infrastructure as Code (IaC) que permite definir infraestructura como c\u00f3digo y desplegarlo autom\u00e1ticamente.</p> <p>Ventajas: - Infraestructura versionada. - Reproducible y consistente. - Multi-cloud (AWS, Azure, GCP). - Preview de cambios antes de aplicarlos.</p> <pre><code># main.tf\nterraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~&gt; 4.0\"\n    }\n  }\n}\n\nprovider \"aws\" {\n  region = \"us-east-1\"\n}\n\nresource \"aws_instance\" \"app_server\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n\n  tags = {\n    Name = \"MiServidor\"\n  }\n}\n\nresource \"aws_s3_bucket\" \"storage\" {\n  bucket = \"mi-bucket-unico\"\n\n  tags = {\n    Environment = \"Production\"\n  }\n}\n</code></pre> <p>Comandos b\u00e1sicos: <pre><code>terraform init    # Inicializar proyecto\nterraform plan    # Ver cambios que se aplicar\u00e1n\nterraform apply   # Aplicar cambios\nterraform destroy # Eliminar infraestructura\n</code></pre></p>"},{"location":"index2/#seccion-10-bases-de-datos","title":"\ud83d\udd39 Secci\u00f3n 10: Bases de Datos","text":""},{"location":"index2/#pregunta-35","title":"\u2753 Pregunta 35:","text":"<p>Preguntas sobre SQL</p>"},{"location":"index2/#respuesta_34","title":"\u2705 Respuesta:","text":"<p>Operaciones b\u00e1sicas: <pre><code>-- SELECT\nSELECT nombre, edad FROM usuarios WHERE edad &gt; 18;\n\n-- JOIN\nSELECT u.nombre, p.titulo\nFROM usuarios u\nINNER JOIN pedidos p ON u.id = p.usuario_id;\n\n-- GROUP BY\nSELECT departamento, COUNT(*) as total\nFROM empleados\nGROUP BY departamento\nHAVING COUNT(*) &gt; 5;\n\n-- Subconsultas\nSELECT nombre FROM usuarios\nWHERE id IN (SELECT usuario_id FROM pedidos WHERE total &gt; 1000);\n\n-- Window Functions\nSELECT nombre, salario,\n       RANK() OVER (PARTITION BY departamento ORDER BY salario DESC) as ranking\nFROM empleados;\n</code></pre></p> <p>\u00cdndices: <pre><code>CREATE INDEX idx_usuario_email ON usuarios(email);\n</code></pre></p> <p>Transacciones: <pre><code>BEGIN;\nUPDATE cuentas SET saldo = saldo - 100 WHERE id = 1;\nUPDATE cuentas SET saldo = saldo + 100 WHERE id = 2;\nCOMMIT; -- o ROLLBACK si hay error\n</code></pre></p> <p>JPA/Hibernate en Spring: <pre><code>@Entity\n@Table(name = \"usuarios\")\npublic class Usuario {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(nullable = false, unique = true)\n    private String email;\n\n    @OneToMany(mappedBy = \"usuario\", cascade = CascadeType.ALL)\n    private List&lt;Pedido&gt; pedidos;\n}\n\n// Repository\npublic interface UsuarioRepository extends JpaRepository&lt;Usuario, Long&gt; {\n    Optional&lt;Usuario&gt; findByEmail(String email);\n\n    @Query(\"SELECT u FROM Usuario u WHERE u.edad &gt; :edad\")\n    List&lt;Usuario&gt; buscarMayoresDe(@Param(\"edad\") int edad);\n}\n</code></pre></p>"},{"location":"index2/#seccion-11-metodologias-agiles","title":"\ud83d\udd39 Secci\u00f3n 11: Metodolog\u00edas \u00c1giles","text":""},{"location":"index2/#pregunta-36","title":"\u2753 Pregunta 36:","text":"<p>\u00bfConoces metodolog\u00edas \u00e1giles? \u00bfEn qu\u00e9 consiste Scrum?</p>"},{"location":"index2/#respuesta_35","title":"\u2705 Respuesta:","text":"<p>Scrum: Marco de trabajo \u00e1gil para desarrollo iterativo e incremental.</p> <p>Roles: - Product Owner (PO): Define prioridades, gestiona backlog. - Scrum Master: Facilita procesos, elimina impedimentos. - Development Team (Devs, QA): Equipo auto-organizado que desarrolla el producto.</p> <p>Artefactos: - Product Backlog: Lista priorizada de funcionalidades. - Sprint Backlog: Tareas seleccionadas para el sprint actual. - Incremento: Producto potencialmente entregable al final del sprint.</p> <p>Ceremonias:</p> <ol> <li>Sprint Planning (Planeaci\u00f3n):</li> <li>Definir objetivo del sprint.</li> <li>Seleccionar historias de usuario.</li> <li>Estimar con Planning Poker (Fibonacci: 1, 2, 3, 5, 8, 13, 21).</li> <li> <p>Criterios: Complejidad + Riesgo + Tama\u00f1o.</p> </li> <li> <p>Daily Stand-up (Diaria):</p> </li> <li>15 minutos m\u00e1ximo.</li> <li>\u00bfQu\u00e9 hice ayer?</li> <li>\u00bfQu\u00e9 har\u00e9 hoy?</li> <li> <p>\u00bfTengo impedimentos?</p> </li> <li> <p>Sprint Review (Revisi\u00f3n):</p> </li> <li>Demostraci\u00f3n del incremento a stakeholders.</li> <li> <p>Feedback del Product Owner.</p> </li> <li> <p>Sprint Retrospective (Retrospectiva):</p> </li> <li>\u00bfQu\u00e9 sali\u00f3 bien?</li> <li>\u00bfQu\u00e9 puede mejorar?</li> <li> <p>Acciones de mejora.</p> </li> <li> <p>Refinamiento (Grooming):</p> </li> <li>Revisar y estimar historias futuras.</li> <li>Aclarar requisitos.</li> </ol> <p>Duraci\u00f3n del Sprint:</p> <ul> <li>T\u00edpicamente 2 semanas (puede ser 1-4 semanas).</li> <li>Tiempo fijo, no se extiende.</li> </ul> <p>Historia de Usuario: <pre><code>Como [rol]\nQuiero [funcionalidad]\nPara [beneficio]\n\nCriterios de aceptaci\u00f3n:\n- Dado que [contexto]\n- Cuando [acci\u00f3n]\n- Entonces [resultado esperado]\n</code></pre></p> <p>Estimaci\u00f3n con Fibonacci:</p> <ul> <li>1: Muy simple (minutos).</li> <li>2-3: Simple (horas).</li> <li>5: Moderado (1 d\u00eda).</li> <li>8: Complejo (2-3 d\u00edas).</li> <li>13+: Muy complejo (debe dividirse).</li> </ul>"},{"location":"index2/#resumen-de-conceptos-clave","title":"\ud83d\udccc Resumen de Conceptos Clave","text":"<p>\u2705 POO: Herencia, Polimorfismo, Abstracci\u00f3n, Encapsulamiento \u2705 SOLID: S-R-P, O-C-P, L-S-P, I-S-P, D-I-P \u2705 Spring: IoC, DI, Anotaciones (@Service, @Repository, @RestController) \u2705 Seguridad: JWT, OAuth2 \u2705 Arquitectura: Monol\u00edtica vs Microservicios, Hexagonal \u2705 Patrones: Factory, Builder, Adapter, DTO, Saga, Circuit Breaker \u2705 DevOps: CI/CD, Docker, Kubernetes, Terraform \u2705 Cloud: AWS (EC2, S3, Lambda, CloudWatch) \u2705 Metodolog\u00eda: Scrum (2 semanas, Planning Poker, Daily, Review, Retrospective)</p>"},{"location":"ml/","title":"Examen Back-End Developer","text":""},{"location":"ml/#1-palindromo","title":"1. Palindromo","text":"<p>Instrucciones: Crear una funci\u00f3n que acepte un string como par\u00e1metro y retorne un valor booleano indicando si el string puede considerarse como un pal\u00edndromo o no. El pal\u00edndromo no se lee igual que de derecha a izquierda (es c\u00edclico). No tener en cuenta los espacios, ni n\u00fameros, ni los siguientes caracteres especiales: \".\", \",\", \"!\"</p> <p>Ejemplo:</p> <ul> <li>\"La ruta nos aport\u00f3 otro paso natural.\" = true</li> <li>\"La ni\u00f1a aport\u00f3 otro paso natural.\" = false</li> </ul> <p>Firma de la funci\u00f3n:</p> <pre><code>public static boolean verificaCapicua(String cadena)\n</code></pre> <p>Soluci\u00f3n 1 (Java Tradicional/Imperativo) - RECOMENDADA: <pre><code>public static boolean verificaCapicua(String cadena) {\n    // Limpiar la cadena: solo letras y convertir a min\u00fasculas\n    StringBuilder limpia = new StringBuilder();\n    for (int i = 0; i &lt; cadena.length(); i++) {\n        char c = cadena.charAt(i);\n        if (Character.isLetter(c)) {\n            limpia.append(Character.toLowerCase(c));\n        }\n    }\n\n    // Verificar si es pal\u00edndromo\n    String str = limpia.toString();\n    int izq = 0;\n    int der = str.length() - 1;\n\n    while (izq &lt; der) {\n        if (str.charAt(izq) != str.charAt(der)) {\n            return false;\n        }\n        izq++;\n        der--;\n    }\n\n    return true;\n}\n</code></pre></p> <p>Soluci\u00f3n 2 (Java con Programaci\u00f3n Funcional) - ALTERNATIVA:</p> <pre><code>import java.util.stream.IntStream;\n\npublic static boolean verificaCapicua(String cadena) {\n    String limpia = cadena.chars()\n        .filter(c -&gt; Character.isLetter(c))\n        .map(Character::toLowerCase)\n        .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append)\n        .toString();\n\n    return IntStream.range(0, limpia.length() / 2)\n        .allMatch(i -&gt; limpia.charAt(i) == limpia.charAt(limpia.length() - 1 - i));\n}\n</code></pre>"},{"location":"ml/#2-web","title":"2. Web","text":"<p>Pregunta: \u00bfPor qu\u00e9 HTTP utiliza TCP como protocolo de transporte?</p> <p>Opciones:</p> <ul> <li>\u2705 Los paquetes deben llegar en el orden correcto.</li> <li>Porque no valida que los paquetes lleguen a destino.</li> <li>Porque es m\u00e1s r\u00e1pido.</li> </ul>"},{"location":"ml/#3-data-structures-2","title":"3. Data Structures 2","text":"<p>Pregunta: \u00bfQu\u00e9 diferencias hay entre implementar el comportamiento de una lista utilizando como estructura de soporte un array vs una lista simplemente enlazada?</p> <p>Opciones (Pick ONE OR MORE):</p> <ul> <li>Tanto lista simplemente enlazada como array permiten insertar en O(1) en el peor caso.</li> <li>La eliminaci\u00f3n de cualquier elemento puede hacerse en O(1) en una lista simplemente enlazada.</li> <li>\u2705 La eliminaci\u00f3n en un array t\u00edpicamente es O(n), siendo n la cantidad de elementos de la lista.</li> <li>Tanto lista simplemente enlazada como array permiten acceder por posici\u00f3n en O(1).</li> <li>\u2705 Si las estructuras est\u00e1n ordenadas el orden de las b\u00fasquedas en el caso del array es O(log2n) y en el caso de la lista simplemente enlazada es O(n), siendo n la cantidad de elementos de la lista.</li> </ul>"},{"location":"ml/#4-poo-1","title":"4. POO 1","text":"<p>Pregunta: \u00bfCu\u00e1les de las siguientes afirmaciones son correctas acerca de IoC (inversi\u00f3n de control)?</p> <p>Opciones (Pick ONE OR MORE):</p> <ul> <li>Solo se puede lograr utilizando un framework (como Spring, Guice, Simple Injector, InversifyJS).</li> <li>IoC es un mecanismo para lograr inyecci\u00f3n de dependencias.</li> <li>\u2705 Inyecci\u00f3n de dependencias es una t\u00e9cnica para lograr IoC.</li> <li>\u2705 Si tengo un componente A que depende de un componente B, IoC me permite ejecutar A sin acoplarme a una implementaci\u00f3n espec\u00edfica de B.</li> </ul>"},{"location":"ml/#5-relational-databases-1","title":"5. Relational Databases 1","text":"<p>Pregunta: Seleccionar las opciones correctas respecto a optimistic locking y pessimistic locking como estrategias de concurrencia en una base de datos.</p> <p>Opciones (Pick ONE OR MORE):</p> <ul> <li>\u2705 El uso de un registro de versi\u00f3n o timestamp forman parte de una posible implementaci\u00f3n de optimistic locking.</li> <li>\u2705 En algunos escenarios el uso de un esquema de pessimistic locking tiene como contrapartida la necesidad de realizar un manejo de concurrencia en la capa de negocio para evitar deadlocks.</li> <li>Por lo general una pol\u00edtica pessimistic locking es mejor para soluciones web con gran tr\u00e1fico.</li> <li>Las bases no relacionales no contemplan estos mecanismos ya que por su concepci\u00f3n no sufren de problemas de concurrencia.</li> <li>\u2705 Los diferentes motores de base de datos ofrecen diferentes granularidades de \"lockes\", entre las m\u00e1s habituales est\u00e1n: a nivel tabla y a nivel fila.</li> </ul>"},{"location":"ml/#6-parentesis-balanceados","title":"6. Par\u00e9ntesis balanceados","text":"<p>Instrucciones: Est\u00e1s dise\u00f1ando un compilador C++ y necesitas verificar que los par\u00e9ntesis de un archivo est\u00e9n balanceados.</p> <p>Los par\u00e9ntesis en un String se consideran balanceados si se cumplen los siguientes criterios:</p> <ul> <li>Todos los par\u00e9ntesis se cierran. Los par\u00e9ntesis est\u00e1n en pares (i, 0 and [). El de la izquierda abre el par y el de la derecha lo cierra.</li> <li>En todos los par\u00e9ntesis anidados dentro de otros, deber\u00e1n estar correctamente emparejados.</li> </ul> <p>Por ejemplo, [()] es un grupo balanceado pero [(]) no lo es.</p> <p>Descripci\u00f3n de la funci\u00f3n: Complet\u00e1 la funci\u00f3n braces en el editor. La funci\u00f3n deber\u00e1 devolver una lista de String donde el string para el \u00edndice i indica si estaban o no balanceados los par\u00e9ntesis para el value. El String, consiste en el valor \"YES\" o \"NO\" correspondiente al valor.</p> <p>Constraints:</p> <ul> <li>1 \u2264 n \u2264 15</li> <li>1 \u2264 largo de cada values \u2264 100</li> <li>Cada values consiste \u00fanicamente de los caracteres {, }, [, ], (, ).</li> </ul> <p>Firma de la funci\u00f3n:</p> <pre><code>public static List&lt;String&gt; balancedBraces(List&lt;String&gt; braces)\n</code></pre> <p>Soluci\u00f3n 1 (Java Tradicional/Imperativo) - RECOMENDADA:</p> <pre><code>import java.util.*;\n\npublic static List&lt;String&gt; balancedBraces(List&lt;String&gt; braces) {\n    List&lt;String&gt; result = new ArrayList&lt;&gt;();\n\n    for (String str : braces) {\n        if (isBalanced(str)) {\n            result.add(\"YES\");\n        } else {\n            result.add(\"NO\");\n        }\n    }\n\n    return result;\n}\n\nprivate static boolean isBalanced(String str) {\n    Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;();\n\n    for (int i = 0; i &lt; str.length(); i++) {\n        char c = str.charAt(i);\n\n        // Si es un par\u00e9ntesis de apertura, lo agregamos a la pila\n        if (c == '(' || c == '{' || c == '[') {\n            stack.push(c);\n        } \n        // Si es un par\u00e9ntesis de cierre, verificamos que coincida\n        else if (c == ')' || c == '}' || c == ']') {\n            if (stack.isEmpty()) {\n                return false;\n            }\n\n            char top = stack.pop();\n\n            if (c == ')' &amp;&amp; top != '(') {\n                return false;\n            }\n            if (c == '}' &amp;&amp; top != '{') {\n                return false;\n            }\n            if (c == ']' &amp;&amp; top != '[') {\n                return false;\n            }\n        }\n    }\n\n    // Al final, la pila debe estar vac\u00eda\n    return stack.isEmpty();\n}\n</code></pre> <p>Soluci\u00f3n 2 (Java con Programaci\u00f3n Funcional) - ALTERNATIVA:</p> <pre><code>import java.util.*;\nimport java.util.stream.Collectors;\n\npublic static List&lt;String&gt; balancedBraces(List&lt;String&gt; braces) {\n    return braces.stream()\n        .map(s -&gt; isBalanced(s) ? \"YES\" : \"NO\")\n        .collect(Collectors.toList());\n}\n\nprivate static boolean isBalanced(String str) {\n    Map&lt;Character, Character&gt; pairs = Map.of(')', '(', '}', '{', ']', '[');\n\n    Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;();\n\n    return str.chars()\n        .mapToObj(c -&gt; (char) c)\n        .allMatch(c -&gt; {\n            if (pairs.containsValue(c)) {\n                stack.push(c);\n                return true;\n            } else if (pairs.containsKey(c)) {\n                return !stack.isEmpty() &amp;&amp; stack.pop() == pairs.get(c);\n            }\n            return false;\n        }) &amp;&amp; stack.isEmpty();\n}\n</code></pre>"},{"location":"ml/#7-testing-1","title":"7. Testing 1","text":"<p>Pregunta: Selecciona la opci\u00f3n correcta acerca de las pruebas.</p> <p>Opciones (Pick ONE):</p> <ul> <li>\u2705 Un test unitario verifica la correcci\u00f3n del m\u00e9todo testeado sin depender de otros componentes.</li> <li>Un test es unitario si contiene todas las validaciones (asserts) necesarias para verificar el comportamiento bajo los distintos escenarios.</li> <li>Ninguna es verdadera.</li> </ul>"},{"location":"ml/#8-test-doubles","title":"8. Test Doubles","text":"<p>Contexto: Teniendo en cuenta el siguiente diagrama de clases:</p> <pre><code>UserService \u2192 UserRepository \u2192 RedisClient \u2192 Third Party Key Value SDK\n</code></pre> <p>Pregunta: En el contexto de un test de integraci\u00f3n en el cual queremos verificar que luego de guardar un usuario, podemos obtener correctamente el usuario recientemente creado indicando su clave, \u00bfcu\u00e1l de las siguientes opciones consideras correcta?</p> <p>Opciones (Pick ONE OR MORE):</p> <ul> <li>Si la instancia de Redis es accesible desde la red donde se ejecuta el test, no har\u00eda ning\u00fan cambio en la aplicaci\u00f3n, ya que durante la ejecuci\u00f3n del test puedo acceder a esa instancia p\u00fablica sin problemas.</li> <li>\u2705 Levantar\u00eda una instancia de Redis embebida en mi aplicaci\u00f3n al ejecutar el test de integraci\u00f3n configurada un profile de ejecuci\u00f3n para test, inicializando RedisClient para que en lugar de utilizar la instancia de Redis original, utilice la embebida.</li> <li>Implementar\u00e1s un stub de KeyValueClient indicando que la operaci\u00f3n getValueById devuelve siempre una instancia prefabricada de User.</li> <li>\u2705 Programar\u00e1s una nueva implementaci\u00f3n de la interfaz KeyValueClient que en lugar de utilizar Redis provea las mismas operaciones pero trabajando con un Map/Dictionary en memoria. Al ejecutar el test de integraci\u00f3n configurar\u00e1s un profile de ejecuci\u00f3n para test que utilice esta implementaci\u00f3n fake en lugar de la productiva.</li> <li>Dado que el SDK es un componente externo (\"third party\"), no puedo proveer una nueva implementaci\u00f3n de la interfaz KeyValueClient.</li> </ul>"},{"location":"ml/#9-ordenamiento-de-lista","title":"9. Ordenamiento de Lista","text":"<p>Considerar la siguiente funci\u00f3n:</p> <pre><code>def func(lista, i = 0, j = -1) {\n    if (j == -1) {\n        j = lista.size()\n    }\n\n    if (i &lt; j) {\n        func(lista, i+1, j)\n    }\n\n    elem = lista[i]\n    k = i-1\n\n    while (k &gt; -1 &amp;&amp; elem &lt; lista[k]) {\n        lista[k+1] = lista[k]\n        k--\n    }\n\n    lista[k+1] = elem\n}\n</code></pre> <p>Pregunta: Si una_lista = [3,3,2,1,4], indicar qu\u00e9 ocurre luego de ejecutar func(una_lista), asumiendo que el pasaje de argumentos es por referencia:</p> <p>Opciones (Pick ONE):</p> <ul> <li>una_lista queda ordenada en forma decreciente (es decir, [4,3,3,2,1])</li> <li>una_lista no resulta modificada</li> <li>\u2705 una_lista queda ordenada en forma creciente (es decir, [1,2,3,3,4])</li> <li>una_lista queda sin elementos repetidos (es decir, [3,2,1,4])</li> <li>Ninguna de las anteriores</li> </ul>"},{"location":"ml/#10-patterns-codigo-de-producto","title":"10. Patterns - C\u00f3digo de Producto","text":"<p>Contexto: Al revisar un pull-request de un integrante de tu equipo encuentras que el siguiente fragmento de c\u00f3digo aparece frecuentemente intercalado con la l\u00f3gica de negocio de consultas y mantenimiento de productos:</p> <pre><code>Product prod = new Product(name, category, null, null, true, currency, price);\n\nif (subCategory != null) {\n    prod.getCategory().setSubCategory(subCategory);\n}\n\nif (reviewer != null) {\n    List&lt;ProductReview&gt; reviews = new ArrayList&lt;ProductReview&gt;();\n    ProductReview review = new ProductReview();\n    review.setReviewer(reviewer);\n    if (reviewDate != null) {\n        review.setReviewDate(reviewDate);\n    }\n    reviews.add(review);\n    prod.setReviews(reviews);\n}\n\nif (prod.getCurrency() != oldCurrency &amp;&amp; prod.getPrice() != oldPrice) {\n    List&lt;PriceUpdate&gt; priceUpds = new ArrayList&lt;PriceUpdate&gt;();\n    PriceUpdate update = new PriceUpdate(oldPrice, price, new Date(updateAt));\n    priceUpds.add(update);\n    prod.setPriceUpdates(priceUpds);\n}\n</code></pre> <p>Pregunta: Luego de discutirlo con ella, deciden que hay oportunidades de simplificar y mejorar la mantenibilidad del c\u00f3digo. Con este objetivo en mente, \u00bfqu\u00e9 patr\u00f3n de dise\u00f1o crees que podr\u00edan utilizar?</p> <p>Opciones (Pick ONE):</p> <ul> <li>\u2705 Builder</li> <li>Composite</li> <li>Prototype</li> </ul>"},{"location":"ml/#11-patterns-facade","title":"11. Patterns - Facade","text":"<p>Pregunta: Tu equipo se encarga del desarrollo de un complejo SDK que permite llevar a cabo pagos el\u00e9ctronicos en plataformas.</p> <p>A pesar de contar con una extensa documentaci\u00f3n, los clientes suelen reportar inconvenientes o incluso se presentan frecuentemente defectos en las integraciones ya que la librer\u00eda cuenta con demasiadas clases con flujos y dependencias complejas que dificultan la correcta utilizaci\u00f3n del SDK.</p> <p>Pregunta: \u00bfQu\u00e9 patr\u00f3n de dise\u00f1o deber\u00edas utilizar para facilitar el uso de tu componente?</p> <p>Opciones (Pick ONE):</p> <ul> <li>Bridge</li> <li>\u2705 Facade</li> <li>Adapter</li> <li>Singleton</li> </ul>"},{"location":"ml/#12-api-rest-nueva-lista","title":"12. API Rest - Nueva lista","text":"<p>Pregunta: Una API Rest permite manejar listas de tareas (to-do list). Dicha API soporta m\u00faltiples listas de tareas, donde cada lista consiste en un id autogenerado, un t\u00edtulo, fecha de creada y una colecci\u00f3n tareas. Las tareas tienen un id autogenerado y un label.</p> <p>Marque las opciones de dise\u00f1o v\u00e1lidas para crear una nueva lista.</p> <p>Opciones (Pick ONE OR MORE):</p> <ul> <li>\u2705 POST a /lists con {\"title\":\"...\", \"tasks\":[...]} como body</li> <li>POST a /lists con {\"id\":\"...\", \"title\":\"...\", \"tasks\":[...]} como body</li> <li>PUT a /lists con {\"title\":\"...\", \"tasks\":[...]} como body</li> <li>PUT a /lists con {\"id\":\"...\", \"title\":\"...\", \"tasks\":[...]} como body</li> <li>UPDATE a /lists con {\"title\":\"...\", \"tasks\":[...]} como body</li> <li>UPDATE a /lists con {\"id\":\"...\", \"title\":\"...\", \"tasks\":[...]} como body</li> </ul>"},{"location":"ml/#13-patterns-sdk-de-pagos","title":"13. Patterns - SDK de Pagos","text":"<p>Pregunta: Tu equipo se encarga del desarrollo de un complejo SDK que permite llevar a cabo pagos el\u00e9ctronicos en plataformas.</p> <p>A pesar de contar con una extensa documentaci\u00f3n, los clientes suelen reportar inconvenientes o incluso se presentan frecuentemente defectos en las integraciones ya que la librer\u00eda cuenta con demasiadas clases con flujos y dependencias complejas que dificultan la correcta utilizaci\u00f3n del SDK.</p> <p>\u00bfQu\u00e9 patr\u00f3n de dise\u00f1o deber\u00edas utilizar para facilitar el uso de tu componente?</p> <p>Opciones (Pick ONE):</p> <ul> <li>Bridge</li> <li>\u2705 Facade</li> <li>Adapter</li> <li>Singleton</li> </ul>"},{"location":"ml/#14-patronos-de-microservicios-2","title":"14. Patronos de microservicios 2","text":"<p>Pregunta: En un sistema distribuido moderno, las colas de mensajes son componentes importantes que proporcionan comunicaci\u00f3n y coordinaci\u00f3n entre las partes del sistema. \u00bfCu\u00e1l de lo siguiente es cierto?</p> <p>Opciones (Pick ONE OR MORE):</p> <ul> <li>Las colas de mensajes hacen que el sistema est\u00e9 m\u00e1s desacoplado.</li> <li>\u2705 Las colas de mensajes aumentan la confiabilidad (reliability) del sistema.</li> <li>Las colas de mensajes, disminuyen el rendimiento general del sistema.</li> <li>Las colas de mensajes aumentan la complejidad de la arquitectura del sistema.</li> </ul>"},{"location":"ml/#15-non-relational-db-1","title":"15. Non relational DB 1","text":"<p>Pregunta: Cu\u00e1les de las siguientes sentencias son verdaderas</p> <p>Opciones (Pick ONE OR MORE):</p> <ul> <li>Cuando tenemos un alto volumen de consultas y todas est\u00e1n basadas en un mismo campo, tiene sentido utilizar una base clave-valor.</li> <li>\u2705 Cuando importa la transaccionalidad y consistencia entre diferentes entidades lo mejor es utilizar una base de datos relacional.</li> <li>Cuando se salva en una base no-sql, es importante tener en cuenta los patrones de acceso a los datos.</li> </ul>"},{"location":"ml/#16-horizontal-scaling","title":"16. Horizontal Scaling","text":"<p>Pregunta: Cuando utilizamos una herramienta que garantiza la consistencia eventual...</p> <p>Opciones (Pick ONE OR MORE):</p> <ul> <li>Entendemos que habr\u00e1 algunos periodos de tiempo en los cuales diferentes nodos no ven la misma informaci\u00f3n.</li> <li>Sabemos que un nodo a la vez puede estar atrasado en actualizar la informaci\u00f3n.</li> <li>Sabemos que ning\u00fan nodo puede responder con informaci\u00f3n obsoleta.</li> <li>Ninguna es verdadera.</li> <li>\u2705 Si hay N nodos, sabemos que al menos N/2+1 de ellos tendr\u00e1 siempre la informaci\u00f3n actualizada.</li> </ul>"},{"location":"ml/#17-concurrency-3","title":"17. Concurrency 3","text":"<p>Pregunta: \u00bfQu\u00e9 son y qu\u00e9 diferencia hay entre un thread (hilo) y un proceso?</p> <p>Opciones (Pick ONE OR MORE):</p> <ul> <li>\u2705 Un proceso puede tener m\u00faltiples threads</li> <li>\u2705 Un thread puede tener m\u00faltiples procesos</li> <li>Los procesos no comparten espacio de memoria</li> <li>Los threads no comparten espacio de memoria</li> </ul>"},{"location":"ml/#18-concurrency-2","title":"18. Concurrency 2","text":"<p>Pregunta: Cu\u00e1les de las siguientes sentencias sobre concurrencia y paralelismo son verdaderas</p> <p>Opciones (Pick ONE OR MORE):</p> <ul> <li>Concurrencia implica tener m\u00e1s de un core, para poder procesar sentencias al mismo tiempo en cada uno de ellos.</li> <li>\u2705 Paralelismo implica tener m\u00e1s de un core, para poder procesar sentencias al mismo tiempo en cada uno de ellos.</li> <li>\u2705 Puede haber concurrencia sin paralelismo.</li> <li>No podemos parallelizar si s\u00f3lo tenemos una tarea que cumplir.</li> </ul>"},{"location":"ml/#19-concurrency-3","title":"19. Concurrency 3","text":"<p>Pregunta: \u00bfQu\u00e9 son y qu\u00e9 diferencia hay entre un thread (hilo) y un proceso?</p> <p>Opciones (Pick ONE OR MORE):</p> <ul> <li>\u2705 Un proceso puede tener m\u00faltiples threads</li> <li>\u2705 Un thread puede tener m\u00faltiples procesos</li> <li>Los procesos no comparten espacio de memoria</li> <li>Los threads no comparten espacio de memoria</li> </ul>"},{"location":"ml/#20-concurrency-2","title":"20. Concurrency 2","text":"<p>Pregunta: Cu\u00e1les de las siguientes sentencias sobre concurrencia y paralelismo son verdaderas</p> <p>Opciones (Pick ONE OR MORE):</p> <ul> <li>Concurrencia implica tener m\u00e1s de un core, para poder procesar sentencias al mismo tiempo en cada uno de ellos.</li> <li>\u2705 Paralelismo implica tener m\u00e1s de un core, para poder procesar sentencias al mismo tiempo en cada uno de ellos.</li> <li>\u2705 Puede haber concurrencia sin paralelismo.</li> <li>No podemos parallelizar si s\u00f3lo tenemos una tarea que cumplir.</li> </ul>"},{"location":"ml/#21-caching-1","title":"21. Caching 1","text":"<p>Pregunta: \u00bfCu\u00e1les de las siguientes sentencias sobre cach\u00e9s son verdaderas?</p> <p>Opciones (Pick ONE OR MORE):</p> <ul> <li>Las aplicaciones son m\u00e1s complejas porque deben agregar l\u00f3gica para invalidar las claves.</li> <li>\u2705 Cuando se utilizan cach\u00e9s locales, puede haber inconsistencias en las respuestas de diferentes nodos.</li> <li>\u2705 Las cach\u00e9s no deber\u00edan ser utilizadas como el almacenamiento principal, sino una forma de optimizar los tiempos de respuesta.</li> </ul>"},{"location":"ml/#22-complejidad-espacial","title":"22. Complejidad espacial","text":"<p>Contexto: La siguiente funci\u00f3n permite calcular el m\u00e1ximo valor de una lista no vac\u00eda de n\u00fameros enteros:</p> <pre><code>def max(lista, i = 0, j = -1) {\n    if (j == -1) {\n        j = lista.size()\n    }\n\n    if (j-i == 1) {\n        return lista[i]\n    }\n\n    max_rec = max(lista, i+1, j)\n\n    if(lista[i] &gt; max_rec) {\n        return lista[i]\n    } else {\n        return max_rec\n    }\n}\n</code></pre> <p>Pregunta: Siendo n la longitud de la lista pasada como argumento, indicar la complejidad espacial de la funci\u00f3n max:</p> <p>Opciones (Pick ONE):</p> <ul> <li>O(1)</li> <li>O(log n)</li> <li>\u2705 O(n)</li> <li>O(n^2)</li> </ul>"},{"location":"ml/#23-pure-functions-1","title":"23. Pure Functions 1","text":"<p>Pregunta: \u00bfCu\u00e1l de los siguientes m\u00e9todos puede ser categorizado como una \"Pure Function\"?</p> <p>Opciones (Pick ONE OR MORE):</p> <p>Opci\u00f3n 1: <pre><code>\u2705 public int sum(int a, int b) {\n    return a + b;\n}\n</code></pre></p> <p>Opci\u00f3n 2: <pre><code>public int sum(int a, int b) {\n    auditService.audit(\"call to sum\", a, b);\n    return a + b;\n}\n</code></pre></p> <p>Opci\u00f3n 3: <pre><code>\u2705 public int sum(int a, int b) {\n    return a + 3 + b + 17;\n}\n</code></pre></p> <p>Opci\u00f3n 4: <pre><code>public int sum(int a, int b) {\n    synchronized(this) {\n        return a + b;\n    }\n}\n</code></pre></p> <p>Opci\u00f3n 5: <pre><code>public int sum(int a, int b) {\n    synchronized(this) {\n        this.currentSum = a + b;\n        return this.currentSum;\n    }\n}\n</code></pre></p>"},{"location":"ml/#24-seguridad-en-general-3","title":"24. Seguridad en general 3","text":"<p>Pregunta: Imagina que est\u00e1s desarrollando una API la cual responde con sugerencias de ciudades a medida que el usuario va escribiendo. \u00bfC\u00f3mo puedes evitar el abuso de tu servicio?</p> <p>Opciones (Pick ONE OR MORE):</p> <ul> <li>\u2705 Se puede utilizar una cach\u00e9 para reducir el impacto de queries similares.</li> <li>\u2705 Podemos analizar la IP que nos consulta, y limitar el acceso cuando el comportamiento es sospechoso.</li> <li>\u2705 Podr\u00edamos aplicar antirebote (debouncing) en el cliente para que la llamada a la API solo se ejecute un n\u00famero limitado de veces en un intervalo de tiempo.</li> </ul>"},{"location":"ml/#25-sql-kyc-levels","title":"25. SQL KYC Levels","text":"<p>Contexto: La tabla <code>user_level</code> guarda informaci\u00f3n hist\u00f3rica de los niveles alcanzados de experiencia (mensual/compras) de nuestros usuarios dentro de Empresa.</p> <p>La tabla est\u00e1 constituida por las columnas:</p> <ul> <li><code>id</code> INT \u2192 id aleatorio de la row</li> <li><code>user_id</code> INT \u2192 El id \u00fanico que identifica a un usuario</li> <li><code>user_level</code> INT \u2192 El nivel de experiencia, cuanto m\u00e1s alto mayor experiencia tiene</li> <li><code>user_type</code> VARCHAR(32) \u2192 Indica el tipo de usuario (puede ser comprador o vendedor)</li> <li><code>date_completed</code> DATE \u2192 indica la fecha en la cual el usuario alcanz\u00f3 el nivel</li> <li><code>date_expired</code> DATE \u2192 indica la fecha en la cual el nivel dej\u00f3 de estar vigente</li> </ul> <p>Un usuario puede tener un \u00fanico nivel vigente. Para representar que un nivel no est\u00e1 vigente el nivel debe tener su <code>date_expired</code> distinto de null.</p> <p>PROBLEMA: Dado un problema de consistencia de datos, existen m\u00e1s de un nivel sin expirar para un mismo usuario. Se necesita obtener para cada usuario, su nivel actual \u00fanico vigente, escriba una query que:</p> <ul> <li>Devuelva el id, user_id, user_level, user_type del nivel vigente de cada usuario del sistema</li> <li>Ordenado de forma descendente en funci\u00f3n a la fecha en que cada usuario alcanz\u00f3 dicho nivel</li> <li>Asegur\u00e1ndose de que el nivel no haya expirado</li> </ul> <p>Ejemplo de tabla:</p> id user_id user_level user_type date_completed date_expired 30 12345678 3 buyer 2021-03-02 2021-03-03 10 12345678 4 buyer 2021-03-03 null 17 12345678 5 buyer 2021-03-04 null <p>Soluci\u00f3n SQL: <pre><code>SELECT \n    ul.id,\n    ul.user_id,\n    ul.user_level,\n    ul.user_type\nFROM user_level ul\nINNER JOIN (\n    SELECT \n        user_id,\n        MAX(date_completed) as max_date\n    FROM user_level\n    WHERE date_expired IS NULL\n    GROUP BY user_id\n) latest ON ul.user_id = latest.user_id \n    AND ul.date_completed = latest.max_date\nWHERE ul.date_expired IS NULL\nORDER BY ul.date_completed DESC;\n</code></pre></p>"},{"location":"ml/#26-pregunta-de-logica-1","title":"26. Pregunta de l\u00f3gica 1","text":"<p>Instrucciones: Tienes un contenedor de forma con dimensiones conocidas x,y. Dentro de este contenedor, se deben almacenar una cantidad de N cajas cada una de ellas con dimensiones a,b.</p> <p>Con base en las dimensiones del contenedor y las cajas:</p> <ol> <li>Determina cu\u00e1ntas cajas caben alineadas en una sola fila a lo largo de la longitud del contenedor.</li> <li>Calcula cu\u00e1ntas filas de cajas pueden formarse a lo ancho del contenedor.</li> <li>Calcula la cantidad total de cajas que se pueden almacenar en el contenedor.</li> </ol> <p>Notas: - Considera que el resultado debe ser cantidades enteras. - Cada excepci\u00f3n o caso borde que genere un error, la salida debe ser [0,0,0] - Las dimensiones de las cajas y contenedor pueden ser menores a 1, mayores de 0 y tener valores decimales.</p> <p>Firma de la funci\u00f3n: <pre><code>public static List&lt;Integer&gt; calculaCantidades(double largo, double ancho, double anchoCaja, double largoCaja)\n</code></pre></p> <p>Soluci\u00f3n (Java Tradicional): <pre><code>import java.util.*;\n\npublic static List&lt;Integer&gt; calculaCantidades(double largo, double ancho, double anchoCaja, double largoCaja) {\n    List&lt;Integer&gt; resultado = new ArrayList&lt;&gt;();\n\n    try {\n        // Validaciones: dimensiones deben ser mayores a 0\n        if (largo &lt;= 0 || ancho &lt;= 0 || anchoCaja &lt;= 0 || largoCaja &lt;= 0) {\n            resultado.add(0);\n            resultado.add(0);\n            resultado.add(0);\n            return resultado;\n        }\n\n        // 1. Cu\u00e1ntas cajas caben en una fila (a lo largo)\n        int cajasPorFila = (int) (largo / largoCaja);\n\n        // 2. Cu\u00e1ntas filas caben (a lo ancho)\n        int numeroFilas = (int) (ancho / anchoCaja);\n\n        // 3. Total de cajas\n        int totalCajas = cajasPorFila * numeroFilas;\n\n        resultado.add(cajasPorFila);\n        resultado.add(numeroFilas);\n        resultado.add(totalCajas);\n\n    } catch (Exception e) {\n        // En caso de cualquier error, retornar [0,0,0]\n        resultado.add(0);\n        resultado.add(0);\n        resultado.add(0);\n    }\n\n    return resultado;\n}\n</code></pre></p>"},{"location":"ml/#27-pregunta-de-logica-2","title":"27. Pregunta de L\u00f3gica 2","text":"<p>Instrucciones: Implementar una aplicaci\u00f3n que procese una lista de n\u00fameros enteros de manera concurrente.</p> <p>El m\u00e9todo debe:</p> <ol> <li>Crear 10 hilos que procesen subconjuntos de la lista de n\u00fameros.</li> <li>Los subconjuntos deben tener m\u00e1ximo 100 elementos.</li> <li>Cada hilo debe sumar los n\u00fameros de su subconjunto.</li> <li>Si en alg\u00fan momento se encuentra un n\u00famero negativo el m\u00e9todo debe:</li> <li>4.1: El hilo debe lanzar una excepci\u00f3n personalizada NegativeNumberException.</li> <li>4.2: Agregar al array de salida el n\u00famero negativo.</li> <li>El programa principal debe capturar las excepciones que ocurran en cualquier hilo y continuar con el procesamiento.</li> </ol> <p>Informaci\u00f3n adicional:</p> <p>El m\u00e9todo recibir\u00e1 2 par\u00e1metros de tipo Integer (rangoA, rangoB) con estos se crea la lista a procesar. El m\u00e9todo retornar\u00e1 una lista con:</p> <ul> <li>Los valores negativos encontrados (criterio 4 y 4.2)</li> <li>Al final de la lista la suma creada en el criterio 3</li> </ul> <p>Debe retornar una lista con los valores negativos encontrados, y al final de la lista la suma de los n\u00fameros pares.</p> <p>Firma de la funci\u00f3n:</p> <pre><code>public static List&lt;Integer&gt; processNumbersConcurrently(long rangoA, long rangoB)\n</code></pre> <p>Soluci\u00f3n (Java Tradicional):</p> <pre><code>import java.util.*;\nimport java.util.concurrent.*;\n\n// Excepci\u00f3n personalizada\nclass NegativeNumberException extends Exception {\n    private int negativeNumber;\n\n    public NegativeNumberException(int number) {\n        super(\"N\u00famero negativo encontrado: \" + number);\n        this.negativeNumber = number;\n    }\n\n    public int getNegativeNumber() {\n        return negativeNumber;\n    }\n}\n\npublic static List&lt;Integer&gt; processNumbersConcurrently(long rangoA, long rangoB) {\n    List&lt;Integer&gt; resultado = new ArrayList&lt;&gt;();\n    List&lt;Integer&gt; numerosNegativos = Collections.synchronizedList(new ArrayList&lt;&gt;());\n    AtomicLong sumaTotal = new AtomicLong(0);\n\n    // Crear la lista de n\u00fameros desde rangoA hasta rangoB\n    List&lt;Long&gt; numeros = new ArrayList&lt;&gt;();\n    for (long i = rangoA; i &lt;= rangoB; i++) {\n        numeros.add(i);\n    }\n\n    // Dividir la lista en chunks de m\u00e1ximo 100 elementos\n    int chunkSize = 100;\n    List&lt;List&lt;Long&gt;&gt; chunks = new ArrayList&lt;&gt;();\n    for (int i = 0; i &lt; numeros.size(); i += chunkSize) {\n        int end = Math.min(i + chunkSize, numeros.size());\n        chunks.add(numeros.subList(i, end));\n    }\n\n    // Crear m\u00e1ximo 10 hilos\n    int numThreads = Math.min(10, chunks.size());\n    ExecutorService executor = Executors.newFixedThreadPool(numThreads);\n    List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;();\n\n    // Procesar cada chunk en un hilo\n    for (List&lt;Long&gt; chunk : chunks) {\n        Future&lt;?&gt; future = executor.submit(() -&gt; {\n            long sumaLocal = 0;\n            try {\n                for (Long num : chunk) {\n                    if (num &lt; 0) {\n                        numerosNegativos.add(num.intValue());\n                        throw new NegativeNumberException(num.intValue());\n                    }\n                    sumaLocal += num;\n                }\n                sumaTotal.addAndGet(sumaLocal);\n            } catch (NegativeNumberException e) {\n                // Capturar la excepci\u00f3n y continuar\n                sumaTotal.addAndGet(sumaLocal);\n            }\n        });\n        futures.add(future);\n    }\n\n    // Esperar a que todos los hilos terminen\n    for (Future&lt;?&gt; future : futures) {\n        try {\n            future.get();\n        } catch (Exception e) {\n            // Continuar con el procesamiento\n        }\n    }\n\n    executor.shutdown();\n\n    // Construir el resultado: negativos + suma al final\n    resultado.addAll(numerosNegativos);\n    resultado.add((int) sumaTotal.get());\n\n    return resultado;\n}\n</code></pre>"},{"location":"ml/#resumen-de-respuestas","title":"Resumen de Respuestas","text":""},{"location":"ml/#ejercicios-de-programacion-java-funcional","title":"Ejercicios de Programaci\u00f3n (Java Funcional):","text":"<ol> <li>Palindromo - verificaCapicua()</li> <li>Par\u00e9ntesis balanceados - balancedBraces()</li> </ol>"},{"location":"ml/#ejercicio-sql","title":"Ejercicio SQL:","text":"<ol> <li>SQL KYC Levels - Query para obtener nivel vigente \u00fanico por usuario</li> </ol>"},{"location":"ml/#preguntas-de-opcion-multiple","title":"Preguntas de Opci\u00f3n M\u00faltiple:","text":"<ul> <li>Web: Los paquetes deben llegar en el orden correcto</li> <li>Data Structures 2: Eliminaci\u00f3n O(n) en arrays, b\u00fasqueda O(log2n) en arrays ordenados</li> <li>POO 1: IoC permite desacoplamiento, DI es t\u00e9cnica para lograr IoC</li> <li>Relational DB 1: Optimistic locking usa versiones/timestamps, locks tienen granularidades</li> <li>Testing 1: Test unitario no depende de otros componentes</li> <li>Test Doubles: Redis embebido o implementaci\u00f3n fake con Map</li> <li>Ordenamiento: Lista queda ordenada creciente</li> <li>Patterns: Builder y Facade</li> <li>API Rest: POST a /lists con body sin id</li> <li>Microservicios: Colas aumentan confiabilidad</li> <li>NoSQL: Transaccionalidad requiere DB relacional</li> <li>Horizontal Scaling: N/2+1 nodos con info actualizada</li> <li>Concurrency: Proceso tiene m\u00faltiples threads, puede haber concurrencia sin paralelismo</li> <li>Caching: Cach\u00e9s locales pueden ser inconsistentes, no usar como almacenamiento principal</li> <li>Complejidad espacial: O(n) por recursi\u00f3n</li> <li>Pure Functions: Sin efectos secundarios ni mutaci\u00f3n de estado</li> <li>Seguridad: Cach\u00e9, rate limiting por IP, debouncing</li> </ul>"},{"location":"pr/","title":"Gu\u00eda de Entrevista: Programaci\u00f3n Reactiva y Spring WebFlux","text":""},{"location":"pr/#fundamentos-de-programacion-reactiva","title":"Fundamentos de Programaci\u00f3n Reactiva","text":""},{"location":"pr/#1-que-es-la-programacion-reactiva-y-cuales-son-sus-principios","title":"1. \u00bfQu\u00e9 es la programaci\u00f3n reactiva y cu\u00e1les son sus principios?","text":"<p>La programaci\u00f3n reactiva es un paradigma declarativo centrado en el trabajo con flujos de datos as\u00edncronos y la propagaci\u00f3n de cambios. Sus principios fundamentales son:</p> <ul> <li>Responsive: El sistema responde de manera oportuna.</li> <li>Resilient: El sistema permanece responsivo ante fallos.</li> <li>Elastic: El sistema se mantiene responsivo bajo carga variable.</li> <li>Message-Driven: Comunicaci\u00f3n basada en mensajes as\u00edncronos.</li> </ul> <p>La implementaci\u00f3n se basa en el patr\u00f3n Observer, donde los consumidores reaccionan a los datos a medida que son emitidos por los productores, en lugar de solicitarlos.</p>"},{"location":"pr/#2-que-es-el-manifiesto-reactivo","title":"2. \u00bfQu\u00e9 es el manifiesto reactivo?","text":"<p>El Manifiesto Reactivo es un documento que establece los principios de los sistemas reactivos. Define que los sistemas reactivos deben ser responsivos, resilientes, el\u00e1sticos y orientados a mensajes. Fue creado por Jonas Bon\u00e9r, Dave Farley, Roland Kuhn y Martin Thompson en 2013, y ha sido firmado por numerosas organizaciones para promover este enfoque de desarrollo de software.</p>"},{"location":"pr/#3-que-es-reactive-streams-y-como-se-implementa-en-java","title":"3. \u00bfQu\u00e9 es Reactive Streams y c\u00f3mo se implementa en Java?","text":"<p>Reactive Streams es una iniciativa para proporcionar un est\u00e1ndar para el procesamiento as\u00edncrono de flujos de datos con contrapresi\u00f3n (backpressure). En Java, se implementa a trav\u00e9s de las interfaces:</p> <ul> <li><code>Publisher&lt;T&gt;</code>: Fuente de datos que emite elementos.</li> <li><code>Subscriber&lt;T&gt;</code>: Consumidor que recibe elementos.</li> <li><code>Subscription</code>: Enlace entre Publisher y Subscriber, permite solicitar elementos (backpressure).</li> <li><code>Processor&lt;T,R&gt;</code>: Combina Publisher y Subscriber, para transformaciones.</li> </ul> <p>Las implementaciones m\u00e1s populares en Java son:</p> <ul> <li>Project Reactor (usado por Spring WebFlux)</li> <li>RxJava</li> <li>Akka Streams</li> <li>Java 9 Flow API</li> </ul>"},{"location":"pr/#4-que-es-la-contrapresion-backpressure-y-por-que-es-importante","title":"4. \u00bfQu\u00e9 es la contrapresi\u00f3n (backpressure) y por qu\u00e9 es importante?","text":"<p>La contrapresi\u00f3n es un mecanismo que permite a un consumidor controlar cu\u00e1ntos elementos puede procesar, evitando ser sobrecargado por un productor que emite datos demasiado r\u00e1pido. Es esencial para sistemas reactivos porque:</p> <ol> <li>Previene desbordamientos de memoria (OutOfMemoryError)</li> <li>Evita la p\u00e9rdida de datos</li> <li>Optimiza el uso de recursos</li> <li>Mejora la estabilidad del sistema</li> </ol> <p>En Reactive Streams, el Subscriber puede solicitar N elementos mediante <code>subscription.request(N)</code>, controlando as\u00ed el flujo de datos.</p>"},{"location":"pr/#spring-webflux","title":"Spring WebFlux","text":""},{"location":"pr/#5-que-es-spring-webflux-y-en-que-se-diferencia-de-spring-mvc","title":"5. \u00bfQu\u00e9 es Spring WebFlux y en qu\u00e9 se diferencia de Spring MVC?","text":"<p>Spring WebFlux es un framework web reactivo no bloqueante que forma parte de Spring 5+. Sus principales diferencias con Spring MVC son:</p> Spring MVC Spring WebFlux Bloqueante (1 hilo por solicitud) No bloqueante (pocos hilos para muchas solicitudes) Basado en Servlet API Basado en Reactive Streams Modelo imperativo Modelo reactivo (declarativo) Contenedor tradicional (Tomcat, Jetty) Contenedores tradicionales o Netty (predeterminado) Procesamiento secuencial Procesamiento as\u00edncrono Mayor consumo de recursos bajo carga Mayor eficiencia con recursos bajo carga <p>WebFlux es ideal para aplicaciones con alto throughput y operaciones intensivas de E/S, mientras que MVC es m\u00e1s simple para aplicaciones CRUD est\u00e1ndar.</p>"},{"location":"pr/#6-cuando-deberias-usar-webflux-en-lugar-de-spring-mvc","title":"6. \u00bfCu\u00e1ndo deber\u00edas usar WebFlux en lugar de Spring MVC?","text":"<p>Deber\u00edas considerar usar WebFlux cuando:</p> <ul> <li>Tu aplicaci\u00f3n requiere manejar muchas conexiones concurrentes (miles)</li> <li>Trabajas con operaciones de E/S de larga duraci\u00f3n o servicios remotos</li> <li>Necesitas streaming de datos (SSE, WebSockets)</li> <li>Tienes alta latencia en operaciones de E/S</li> <li>Quieres maximizar el uso de recursos del servidor</li> <li>Trabajas con microservicios que se comunican de forma as\u00edncrona</li> </ul> <p>No es recomendable cuando:</p> <ul> <li>Tu equipo no est\u00e1 familiarizado con programaci\u00f3n reactiva</li> <li>Usas bibliotecas o APIs bloqueantes</li> <li>Necesitas integrar con sistemas que no tienen soporte reactivo</li> <li>Las operaciones son principalmente de CPU y no de E/S</li> <li>No hay necesidad de alto throughput o gran concurrencia</li> </ul>"},{"location":"pr/#7-como-se-configuran-las-rutas-en-webflux-usando-el-enfoque-funcional","title":"7. \u00bfC\u00f3mo se configuran las rutas en WebFlux usando el enfoque funcional?","text":"<p>WebFlux ofrece un enfoque funcional para definir rutas usando <code>RouterFunction</code> y <code>HandlerFunction</code>:</p> <pre><code>@Configuration\npublic class UsuarioRouter {\n\n    @Bean\n    public RouterFunction&lt;ServerResponse&gt; rutasUsuario(UsuarioHandler handler) {\n        return route()\n            .GET(\"/usuarios\", handler::listarUsuarios)\n            .GET(\"/usuarios/{id}\", handler::obtenerUsuario)\n            .POST(\"/usuarios\", handler::crearUsuario)\n            .PUT(\"/usuarios/{id}\", handler::actualizarUsuario)\n            .DELETE(\"/usuarios/{id}\", handler::eliminarUsuario)\n            .build();\n    }\n}\n\n@Component\npublic class UsuarioHandler {\n\n    public Mono&lt;ServerResponse&gt; listarUsuarios(ServerRequest request) {\n        return ServerResponse.ok()\n            .contentType(MediaType.APPLICATION_JSON)\n            .body(servicioUsuario.findAll(), Usuario.class);\n    }\n\n    // Otros m\u00e9todos handler...\n}\n</code></pre> <p>Este enfoque separa claramente el enrutamiento de la l\u00f3gica de manipulaci\u00f3n, permitiendo un c\u00f3digo m\u00e1s declarativo y componible.</p>"},{"location":"pr/#8-que-son-los-controladores-reactivos-en-webflux-y-como-se-implementan","title":"8. \u00bfQu\u00e9 son los controladores reactivos en WebFlux y c\u00f3mo se implementan?","text":"<p>Los controladores reactivos en WebFlux son similares a los controladores de Spring MVC, pero devuelven tipos reactivos (<code>Mono&lt;T&gt;</code> o <code>Flux&lt;T&gt;</code>). Se implementan usando la anotaci\u00f3n <code>@RestController</code>:</p> <pre><code>@RestController\n@RequestMapping(\"/usuarios\")\npublic class UsuarioController {\n\n    private final UsuarioService usuarioService;\n\n    @Autowired\n    public UsuarioController(UsuarioService usuarioService) {\n        this.usuarioService = usuarioService;\n    }\n\n    @GetMapping\n    public Flux&lt;Usuario&gt; listarUsuarios() {\n        return usuarioService.findAll();\n    }\n\n    @GetMapping(\"/{id}\")\n    public Mono&lt;Usuario&gt; obtenerUsuarioPorId(@PathVariable String id) {\n        return usuarioService.findById(id);\n    }\n\n    @PostMapping\n    @ResponseStatus(HttpStatus.CREATED)\n    public Mono&lt;Usuario&gt; crearUsuario(@RequestBody Usuario usuario) {\n        return usuarioService.save(usuario);\n    }\n}\n</code></pre> <p>Los controladores reactivos procesan las solicitudes de forma no bloqueante, permitiendo manejar m\u00e1s solicitudes con menos recursos.</p>"},{"location":"pr/#mono-y-flux","title":"Mono y Flux","text":""},{"location":"pr/#9-que-son-mono-y-flux-en-project-reactor","title":"9. \u00bfQu\u00e9 son Mono y Flux en Project Reactor?","text":"<p><code>Mono</code> y <code>Flux</code> son las implementaciones principales de <code>Publisher</code> en Project Reactor:</p> <ul> <li>Mono: Representa una secuencia as\u00edncrona de 0 o 1 elemento. Equivalente reactivo a <code>CompletableFuture&lt;T&gt;</code> o <code>Optional&lt;T&gt;</code>. <li>Flux: Representa una secuencia as\u00edncrona de 0 a N elementos. Equivalente reactivo a <code>Stream&lt;T&gt;</code> o <code>List&lt;T&gt;</code>. <p>Ambos tipos ofrecen operadores para transformar, combinar y manipular flujos de datos de manera declarativa y no bloqueante.</p> <pre><code>// Ejemplo de Mono\nMono&lt;Usuario&gt; usuarioMono = repositorio.findById(\"123\");\n\n// Ejemplo de Flux\nFlux&lt;Usuario&gt; usuariosFlux = repositorio.findAll();\n</code></pre>"},{"location":"pr/#10-cuales-son-los-principales-operadores-de-mono-y-flux-y-para-que-se-utilizan","title":"10. \u00bfCu\u00e1les son los principales operadores de Mono y Flux y para qu\u00e9 se utilizan?","text":"<p>Project Reactor ofrece numerosos operadores para trabajar con flujos reactivos:</p> <p>Operadores de Transformaci\u00f3n:</p> <ul> <li> <p>map: Transforma cada elemento aplicando una funci\u00f3n que devuelve un nuevo valor.   <pre><code>Flux&lt;String&gt; nombres = usuariosFlux.map(Usuario::getNombre);\n</code></pre></p> </li> <li> <p>flatMap: Transforma cada elemento en un Publisher y \"aplana\" los resultados en un \u00fanico flujo. Los elementos pueden entremezclarse (orden no garantizado).   <pre><code>Flux&lt;Comentario&gt; comentarios = usuarios\n    .flatMap(u -&gt; comentarioRepository.findByUsuarioId(u.getId()));\n</code></pre></p> </li> <li> <p>concatMap: Similar a flatMap, pero preserva el orden de los elementos originales, procesando cada fuente completamente antes de pasar a la siguiente.   <pre><code>Flux&lt;Comentario&gt; comentariosOrdenados = usuarios\n    .concatMap(u -&gt; comentarioRepository.findByUsuarioId(u.getId()));\n</code></pre></p> </li> <li> <p>flatMapMany: Espec\u00edfico para Mono, convierte un Mono en un Flux aplicando una funci\u00f3n que devuelve m\u00faltiples elementos.   <pre><code>Mono&lt;Usuario&gt; usuarioMono = repository.findById(id);\nFlux&lt;Comentario&gt; comentarios = usuarioMono\n    .flatMapMany(u -&gt; comentarioRepository.findByUsuarioId(u.getId()));\n</code></pre></p> </li> </ul> <p>Operadores de Filtrado:</p> <ul> <li> <p>filter: Incluye solo los elementos que cumplen con el predicado dado.   <pre><code>Flux&lt;Usuario&gt; adultos = usuarios.filter(u -&gt; u.getEdad() &gt;= 18);\n</code></pre></p> </li> <li> <p>distinct: Elimina elementos duplicados, manteniendo solo la primera ocurrencia.   <pre><code>Flux&lt;String&gt; distintas = palabras.distinct();\n</code></pre></p> </li> <li> <p>take: Limita el flujo a un n\u00famero espec\u00edfico de elementos, tomando solo los primeros N elementos.   <pre><code>Flux&lt;Usuario&gt; primerosTres = usuarios.take(3);\n</code></pre></p> </li> <li> <p>skip: Omite los primeros N elementos del flujo y emite los restantes.   <pre><code>Flux&lt;Usuario&gt; despuesDeDos = usuarios.skip(2);\n</code></pre></p> </li> </ul> <p>Operadores de Combinaci\u00f3n:</p> <ul> <li> <p>zip: Combina elementos de m\u00faltiples Publishers emparej\u00e1ndolos por posici\u00f3n.   <pre><code>Flux&lt;UsuarioConEstadistica&gt; combinado = Flux.zip(\n    usuarios, estadisticas, (u, e) -&gt; new UsuarioConEstadistica(u, e)\n);\n</code></pre></p> </li> <li> <p>merge: Combina m\u00faltiples Publishers en uno solo, entremezclando elementos a medida que llegan.   <pre><code>Flux&lt;Notificacion&gt; todas = Flux.merge(notificacionesEmail, notificacionesSMS);\n</code></pre></p> </li> <li> <p>concat: Combina m\u00faltiples Publishers secuencialmente, esperando a que cada uno complete.   <pre><code>Flux&lt;Dato&gt; todosDatos = Flux.concat(datosCache, datosDB);\n</code></pre></p> </li> </ul> <p>Operadores de Reducci\u00f3n:</p> <ul> <li> <p>reduce: Combina todos los elementos en un \u00fanico valor aplicando una funci\u00f3n acumuladora.   <pre><code>Mono&lt;Integer&gt; suma = numeros.reduce(0, (acumulado, actual) -&gt; acumulado + actual);\n</code></pre></p> </li> <li> <p>count: Cuenta el n\u00famero total de elementos en el flujo.   <pre><code>Mono&lt;Long&gt; total = usuarios.count();\n</code></pre></p> </li> <li> <p>collectList: Recolecta todos los elementos en una lista.   <pre><code>Mono&lt;List&lt;Usuario&gt;&gt; listaUsuarios = usuarios.collectList();\n</code></pre></p> </li> <li> <p>collectMap: Recolecta elementos en un Map usando una funci\u00f3n para determinar las claves.   <pre><code>Mono&lt;Map&lt;String, Usuario&gt;&gt; mapaPorId = usuarios.collectMap(Usuario::getId);\n</code></pre></p> </li> </ul> <p>Manejo de errores:</p> <ul> <li> <p>onErrorReturn: Sustituye el error con un valor predeterminado y completa el flujo.   <pre><code>Mono&lt;Usuario&gt; usuario = repository.findById(id)\n    .onErrorReturn(new Usuario(\"default\", \"Usuario por defecto\"));\n</code></pre></p> </li> <li> <p>onErrorResume: Cambia a un Publisher alternativo cuando ocurre un error.   <pre><code>Mono&lt;Usuario&gt; usuario = primaryRepo.findById(id)\n    .onErrorResume(e -&gt; backupRepo.findById(id));\n</code></pre></p> </li> <li> <p>retry: Reintenta toda la secuencia un n\u00famero espec\u00edfico de veces en caso de error.   <pre><code>Mono&lt;Datos&gt; datos = servicio.getDatosInestables().retry(3);\n</code></pre></p> </li> </ul> <p>Contexto y Threading:</p> <ul> <li> <p>publishOn: Cambia el Scheduler donde los operadores subsiguientes se ejecutar\u00e1n.   <pre><code>Flux&lt;Data&gt; datos = repository.findAll()\n    .publishOn(Schedulers.parallel())\n    .map(this::procesoPesado);\n</code></pre></p> </li> <li> <p>subscribeOn: Especifica el Scheduler donde la suscripci\u00f3n inicial se ejecutar\u00e1.   <pre><code>Flux&lt;Data&gt; datos = operacionBloqueanteWrapper()\n    .subscribeOn(Schedulers.boundedElastic());\n</code></pre></p> </li> </ul>"},{"location":"pr/#11-como-se-maneja-la-suscripcion-en-reactor-y-que-ocurre-si-no-te-suscribes","title":"11. \u00bfC\u00f3mo se maneja la suscripci\u00f3n en Reactor y qu\u00e9 ocurre si no te suscribes?","text":"<p>En Reactor, la suscripci\u00f3n es el desencadenante que inicia el flujo de datos desde el <code>Publisher</code> hacia el <code>Subscriber</code>. Sin suscripci\u00f3n, nada ocurre (lazy evaluation).</p> <p>Una suscripci\u00f3n completa incluye tres callbacks: <pre><code>flux.subscribe(\n    data -&gt; System.out.println(\"Dato: \" + data),     // onNext\n    error -&gt; System.err.println(\"Error: \" + error),  // onError\n    () -&gt; System.out.println(\"Completado\")           // onComplete\n);\n</code></pre></p> <p>Si no te suscribes:</p> <ol> <li>No se ejecuta ninguna operaci\u00f3n</li> <li>No se emiten datos</li> <li>No se generan efectos secundarios</li> </ol> <p>Esto se conoce como \"ensamblaje vs ejecuci\u00f3n\" - puedes construir un flujo complejo sin ejecutarlo hasta la suscripci\u00f3n.</p>"},{"location":"pr/#12-como-se-manejan-los-errores-en-programacion-reactiva-con-reactor","title":"12. \u00bfC\u00f3mo se manejan los errores en programaci\u00f3n reactiva con Reactor?","text":"<p>Reactor ofrece varios operadores para manejar errores de forma declarativa:</p> <ul> <li> <p>onErrorReturn: Proporciona un valor por defecto en caso de error   <pre><code>Mono&lt;Usuario&gt; usuarioODefault = usuarioMono\n    .onErrorReturn(new Usuario(\"default\"));\n</code></pre></p> </li> <li> <p>onErrorResume: Cambia a un Publisher alternativo en caso de error   <pre><code>Mono&lt;Usuario&gt; conRecuperacion = usuarioMono\n    .onErrorResume(e -&gt; fallbackService.getUsuario());\n</code></pre></p> </li> <li> <p>onErrorMap: Transforma un error en otro tipo de error   <pre><code>Mono&lt;Usuario&gt; conErrorMapeado = usuarioMono\n    .onErrorMap(RuntimeException.class, \n        e -&gt; new UsuarioException(\"Error al obtener usuario\", e));\n</code></pre></p> </li> <li> <p>doOnError: Ejecuta un efecto secundario cuando ocurre un error   <pre><code>Mono&lt;Usuario&gt; conLog = usuarioMono\n    .doOnError(e -&gt; log.error(\"Error en flujo: {}\", e.getMessage()));\n</code></pre></p> </li> <li> <p>retry/retryWhen: Reintenta la secuencia en caso de error   <pre><code>Mono&lt;Usuario&gt; conReintento = usuarioMono.retry(3);\n</code></pre></p> </li> </ul> <p>Los errores en programaci\u00f3n reactiva siguen el principio de \"fail-fast\" y terminan la secuencia inmediatamente a menos que sean manejados.</p>"},{"location":"pr/#webclient-y-webtestclient","title":"WebClient y WebTestClient","text":""},{"location":"pr/#13-que-es-webclient-y-como-se-utiliza-para-consumir-apis","title":"13. \u00bfQu\u00e9 es WebClient y c\u00f3mo se utiliza para consumir APIs?","text":"<p>WebClient es el cliente HTTP reactivo de Spring WebFlux, dise\u00f1ado para realizar peticiones de forma no bloqueante. Reemplaza al antiguo RestTemplate con un enfoque reactivo.</p> <p>Caracter\u00edsticas principales:</p> <ul> <li>No bloqueante y reactivo</li> <li>Fluent API para configuraci\u00f3n y peticiones</li> <li>Soporte para codificaci\u00f3n/decodificaci\u00f3n de objetos</li> <li>Manejo de errores reactivo</li> <li>Integraci\u00f3n con ReactiveAdapterRegistry</li> </ul> <p>Ejemplo b\u00e1sico: <pre><code>WebClient webClient = WebClient.create(\"https://api.ejemplo.com\");\n\nMono&lt;Usuario&gt; usuario = webClient.get()\n    .uri(\"/usuarios/{id}\", 123)\n    .header(\"Authorization\", \"Bearer token\")\n    .retrieve()\n    .bodyToMono(Usuario.class);\n\n// O con m\u00e1s control sobre respuestas HTTP\nMono&lt;Usuario&gt; usuarioDetallado = webClient.get()\n    .uri(\"/usuarios/{id}\", 123)\n    .accept(MediaType.APPLICATION_JSON)\n    .exchangeToMono(response -&gt; {\n        if (response.statusCode().equals(HttpStatus.OK)) {\n            return response.bodyToMono(Usuario.class);\n        } else if (response.statusCode().is4xxClientError()) {\n            return Mono.error(new ClienteException(\"Error de cliente\"));\n        } else {\n            return Mono.error(new ServidorException(\"Error de servidor\"));\n        }\n    });\n</code></pre></p>"},{"location":"pr/#14-cuales-son-las-ventajas-de-usar-webclient-sobre-resttemplate","title":"14. \u00bfCu\u00e1les son las ventajas de usar WebClient sobre RestTemplate?","text":"<p>WebClient ofrece varias ventajas sobre RestTemplate:</p> <ol> <li>Modelo no bloqueante: Utiliza menos hilos para manejar m\u00e1s peticiones.</li> <li>API funcional y fluida: M\u00e1s expresiva y componible.</li> <li>Streaming reactivo: Soporte para flujos de datos continuos (SSE, WebSockets).</li> <li>Backpressure: Control de flujo para evitar sobrecarga.</li> <li>Cancelaci\u00f3n: Permite cancelar peticiones en curso.</li> <li>Composici\u00f3n: Facilita la combinaci\u00f3n de m\u00faltiples llamadas API.</li> <li>Mejor testabilidad: Dise\u00f1ado para ser f\u00e1cilmente mockeado.</li> <li>Compatibilidad con Reactor y RxJava: Interoperabilidad con otras librer\u00edas reactivas.</li> </ol> <pre><code>// RestTemplate (bloqueante)\nResponseEntity&lt;Usuario&gt; response = restTemplate.getForEntity(\"/usuarios/{id}\", Usuario.class, id);\nUsuario usuario = response.getBody();\n\n// WebClient (no bloqueante)\nMono&lt;Usuario&gt; usuarioMono = webClient.get()\n    .uri(\"/usuarios/{id}\", id)\n    .retrieve()\n    .bodyToMono(Usuario.class);\n</code></pre>"},{"location":"pr/#15-que-es-webtestclient-y-como-se-utiliza-para-probar-endpoints-reactivos","title":"15. \u00bfQu\u00e9 es WebTestClient y c\u00f3mo se utiliza para probar endpoints reactivos?","text":"<p>WebTestClient es una herramienta especializada para probar aplicaciones WebFlux, proporcionando una API fluida para realizar y verificar solicitudes HTTP. Puede trabajar contra servidores reales, controladores Spring WebFlux o funciones de enrutamiento.</p> <p>Caracter\u00edsticas:</p> <ul> <li>API fluida similar a WebClient</li> <li>Aserciones espec\u00edficas para pruebas</li> <li>Soporte para verificar respuestas reactivas</li> <li>Compatible con JUnit y otros frameworks de pruebas</li> </ul> <pre><code>@SpringBootTest\n@AutoConfigureWebTestClient\nclass UsuarioControllerTest {\n\n    @Autowired\n    private WebTestClient webTestClient;\n\n    @Test\n    void testObtenerUsuario() {\n        webTestClient.get()\n            .uri(\"/usuarios/{id}\", 1)\n            .accept(MediaType.APPLICATION_JSON)\n            .exchange()\n            .expectStatus().isOk()\n            .expectHeader().contentType(MediaType.APPLICATION_JSON)\n            .expectBody(Usuario.class)\n            .value(usuario -&gt; {\n                assertThat(usuario.getId()).isEqualTo(\"1\");\n                assertThat(usuario.getNombre()).isEqualTo(\"Juan\");\n            });\n    }\n\n    @Test\n    void testListarUsuarios() {\n        webTestClient.get()\n            .uri(\"/usuarios\")\n            .exchange()\n            .expectStatus().isOk()\n            .expectBodyList(Usuario.class)\n            .hasSize(3)\n            .contains(new Usuario(\"1\", \"Juan\"));\n    }\n}\n</code></pre> <p>Para probar controladores espec\u00edficos sin iniciar toda la aplicaci\u00f3n: <pre><code>@WebFluxTest(UsuarioController.class)\nclass UsuarioControllerTest {\n    @Autowired\n    private WebTestClient webTestClient;\n\n    @MockBean\n    private UsuarioService usuarioService;\n\n    @Test\n    void testObtenerUsuario() {\n        when(usuarioService.findById(\"1\"))\n            .thenReturn(Mono.just(new Usuario(\"1\", \"Juan\")));\n\n        // Prueba como en el ejemplo anterior\n    }\n}\n</code></pre></p>"},{"location":"pr/#16-como-se-manejan-las-pruebas-de-integracion-en-aplicaciones-webflux","title":"16. \u00bfC\u00f3mo se manejan las pruebas de integraci\u00f3n en aplicaciones WebFlux?","text":"<p>Las pruebas de integraci\u00f3n en WebFlux utilizan <code>WebTestClient</code> con un enfoque m\u00e1s completo:</p> <ol> <li>Configuraci\u00f3n de prueba:</li> </ol> <pre><code>@SpringBootTest\n@AutoConfigureWebTestClient\nclass ApiIntegrationTest {\n\n    @Autowired\n    private WebTestClient webTestClient;\n\n    // Tests...\n}\n</code></pre> <ol> <li>Pruebas con base de datos reactiva (ej. MongoDB reactivo):</li> </ol> <pre><code>@DataMongoTest\n@Import(UsuarioRepositoryImpl.class)\nclass UsuarioRepositoryTest {\n\n    @Autowired\n    private UsuarioRepository repository;\n\n    @Test\n    void testGuardarYBuscar() {\n        Usuario usuario = new Usuario(\"1\", \"Juan\");\n\n        StepVerifier.create(repository.save(usuario))\n            .expectNextMatches(u -&gt; u.getId().equals(\"1\"))\n            .verifyComplete();\n\n        StepVerifier.create(repository.findById(\"1\"))\n            .expectNext(usuario)\n            .verifyComplete();\n    }\n}\n</code></pre> <ol> <li>Pruebas de flujos de datos reactivos con StepVerifier:</li> </ol> <pre><code>@Test\nvoid testStreamingEndpoint() {\n    Flux&lt;String&gt; responseFlux = webTestClient.get()\n        .uri(\"/stream/datos\")\n        .exchange()\n        .expectStatus().isOk()\n        .returnResult(String.class)\n        .getResponseBody();\n\n    StepVerifier.create(responseFlux)\n        .expectNext(\"dato1\")\n        .expectNext(\"dato2\")\n        .expectNext(\"dato3\")\n        .expectComplete()\n        .verify(Duration.ofSeconds(5));\n}\n</code></pre> <ol> <li>Pruebas de WebSockets:</li> </ol> <pre><code>@Test\nvoid testWebSocketEndpoint() {\n    WebSocketClient client = new ReactorNettyWebSocketClient();\n    URI uri = URI.create(\"ws://localhost:\" + port + \"/ws\");\n\n    Mono&lt;Void&gt; output = client.execute(uri, session -&gt; {\n        Mono&lt;Void&gt; input = session.send(Mono.just(session.textMessage(\"Hola\")));\n        Mono&lt;Void&gt; receive = session.receive()\n            .map(WebSocketMessage::getPayloadAsText)\n            .doOnNext(text -&gt; {\n                assertThat(text).isEqualTo(\"HOLA\");\n            })\n            .then();\n\n        return input.then(receive);\n    });\n\n    StepVerifier.create(output)\n        .expectComplete()\n        .verify(Duration.ofSeconds(5));\n}\n</code></pre>"},{"location":"pr/#desventajas-y-consideraciones","title":"Desventajas y Consideraciones","text":""},{"location":"pr/#17-cuales-son-las-desventajas-de-usar-reactive-streams","title":"17. \u00bfCu\u00e1les son las desventajas de usar Reactive Streams?","text":"<p>A pesar de sus beneficios, la programaci\u00f3n reactiva tiene varias desventajas:</p> <ol> <li>Curva de aprendizaje pronunciada: El paradigma reactivo requiere cambiar la forma de pensar.</li> <li>Debugging m\u00e1s complejo: Las stack traces son menos intuitivas y m\u00e1s dif\u00edciles de seguir.</li> <li>Mayor complejidad de c\u00f3digo: El c\u00f3digo reactivo puede ser m\u00e1s dif\u00edcil de leer y mantener.</li> <li>Posible sobreutilizaci\u00f3n: No todas las aplicaciones necesitan reactividad.</li> <li>Ecosistema limitado: No todas las bibliotecas tienen versiones reactivas.</li> <li>Problemas de desarrollo: Las herramientas de desarrollo (IDEs, profilers) est\u00e1n menos optimizadas.</li> <li>Mayor uso de memoria: En algunos casos, puede requerir m\u00e1s memoria que el enfoque imperativo.</li> <li>Riesgo de bloqueo accidental: Mezclar c\u00f3digo bloqueante con no bloqueante puede degradar el rendimiento.</li> </ol> <p>Ejemplo de c\u00f3digo m\u00e1s complejo: <pre><code>// Imperativo (simple)\nList&lt;Usuario&gt; usuarios = usuarioRepository.findAll();\nList&lt;Usuario&gt; activos = usuarios.stream()\n    .filter(Usuario::isActivo)\n    .collect(Collectors.toList());\n\n// Reactivo (m\u00e1s complejo)\nFlux&lt;Usuario&gt; usuariosFlux = usuarioRepository.findAll();\nMono&lt;List&lt;Usuario&gt;&gt; activosMono = usuariosFlux\n    .filter(Usuario::isActivo)\n    .collectList()\n    .doOnError(e -&gt; log.error(\"Error: {}\", e.getMessage()))\n    .onErrorResume(e -&gt; Mono.just(Collections.emptyList()));\n</code></pre></p>"},{"location":"pr/#18-cuando-no-deberias-usar-programacion-reactiva","title":"18. \u00bfCu\u00e1ndo NO deber\u00edas usar programaci\u00f3n reactiva?","text":"<p>No deber\u00edas usar programaci\u00f3n reactiva en estos escenarios:</p> <ol> <li>Aplicaciones CRUD simples: Las aplicaciones con operaciones simples de base de datos sin necesidad de alta concurrencia.</li> <li>Equipos sin experiencia: Cuando el equipo no est\u00e1 familiarizado con el paradigma reactivo y no hay tiempo para capacitaci\u00f3n.</li> <li>Dependencias bloqueantes: Cuando dependes de bibliotecas o APIs que son inherentemente bloqueantes.</li> <li>Operaciones intensivas de CPU: La programaci\u00f3n reactiva brilla en operaciones de E/S, no tanto en c\u00e1lculos intensivos.</li> <li>Necesidades de rendimiento modestas: Si tu aplicaci\u00f3n no requiere manejar miles de conexiones concurrentes.</li> <li>Proyectos con plazos ajustados: La curva de aprendizaje puede afectar los plazos de entrega.</li> <li>Cuando la simplicidad es prioritaria: La legibilidad y mantenibilidad pueden verse comprometidas.</li> <li>Aplicaciones batch o de procesamiento por lotes: Donde el procesamiento secuencial es m\u00e1s apropiado.</li> </ol>"},{"location":"pr/#19-como-afecta-la-programacion-reactiva-al-rendimiento-y-consumo-de-recursos","title":"19. \u00bfC\u00f3mo afecta la programaci\u00f3n reactiva al rendimiento y consumo de recursos?","text":"<p>La programaci\u00f3n reactiva puede tener diferentes impactos en el rendimiento:</p> <p>Beneficios:</p> <ul> <li>Mejor uso de CPU: Menos hilos pueden manejar m\u00e1s solicitudes.</li> <li>Mayor throughput: Puede procesar m\u00e1s solicitudes por segundo.</li> <li>Mejor manejo de concurrencia: Sin bloqueos de hilos para operaciones de E/S.</li> <li>Escalabilidad vertical: Aprovecha mejor los recursos de una sola m\u00e1quina.</li> <li>Menor sobrecarga de contexto: Menos cambios de contexto entre hilos.</li> </ul> <p>Consideraciones:</p> <ul> <li>Overhead inicial: Mayor uso de memoria para estructuras reactivas.</li> <li>Presi\u00f3n en GC: M\u00e1s objetos temporales pueden aumentar la actividad del recolector de basura.</li> <li>Complejidad de optimizaci\u00f3n: M\u00e1s dif\u00edcil de perfilar y optimizar.</li> <li>Rendimiento vs. complejidad: El beneficio debe justificar la complejidad adicional.</li> </ul> <p>Comparativa de rendimiento:</p> <ul> <li>Con pocas conexiones simult\u00e1neas (&lt; 100): Spring MVC puede ser m\u00e1s eficiente.</li> <li>Con muchas conexiones simult\u00e1neas (&gt; 1000): WebFlux suele ofrecer mejor rendimiento.</li> <li>Con operaciones bloqueantes: WebFlux puede degradarse significativamente.</li> </ul>"},{"location":"pr/#20-como-se-integra-la-seguridad-en-aplicaciones-webflux","title":"20. \u00bfC\u00f3mo se integra la seguridad en aplicaciones WebFlux?","text":"<p>Spring Security se integra con WebFlux a trav\u00e9s de un modelo reactivo:</p> <pre><code>@Configuration\n@EnableWebFluxSecurity\npublic class SecurityConfig {\n\n    @Bean\n    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n        return http\n            .csrf().disable()\n            .authorizeExchange()\n                .pathMatchers(\"/public/**\").permitAll()\n                .pathMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n                .anyExchange().authenticated()\n            .and()\n            .httpBasic()\n            .and()\n            .formLogin()\n            .and()\n            .build();\n    }\n\n    @Bean\n    public ReactiveUserDetailsService userDetailsService() {\n        UserDetails user = User.withDefaultPasswordEncoder()\n            .username(\"user\")\n            .password(\"password\")\n            .roles(\"USER\")\n            .build();\n\n        UserDetails admin = User.withDefaultPasswordEncoder()\n            .username(\"admin\")\n            .password(\"password\")\n            .roles(\"ADMIN\")\n            .build();\n\n        return new MapReactiveUserDetailsService(user, admin);\n    }\n}\n</code></pre> <p>Para trabajar con JWT: <pre><code>@Bean\npublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n    return http\n        .csrf().disable()\n        .authorizeExchange()\n            .pathMatchers(\"/auth/**\").permitAll()\n            .anyExchange().authenticated()\n        .and()\n        .addFilterAt(jwtAuthenticationFilter, SecurityWebFiltersOrder.HTTP_BASIC)\n        .exceptionHandling()\n            .authenticationEntryPoint((swe, e) -&gt; \n                Mono.fromRunnable(() -&gt; swe.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED)))\n        .and()\n        .build();\n}\n</code></pre></p> <p>La autenticaci\u00f3n y autorizaci\u00f3n en WebFlux se basan en operadores reactivos: <pre><code>@GetMapping(\"/usuario/actual\")\npublic Mono&lt;Usuario&gt; getUsuarioActual(Authentication authentication) {\n    return Mono.justOrEmpty(authentication)\n        .map(Authentication::getName)\n        .flatMap(usuarioService::findByUsername);\n}\n\n// O usando SecurityContextHolder reactivo\npublic Mono&lt;Usuario&gt; getUsuarioActual() {\n    return ReactiveSecurityContextHolder.getContext()\n        .map(SecurityContext::getAuthentication)\n        .map(Authentication::getName)\n        .flatMap(usuarioService::findByUsername);\n}\n</code></pre></p>"},{"location":"spring/","title":"Gu\u00eda de Entrevista Java y Spring Boot","text":""},{"location":"spring/#fundamentos-de-java","title":"Fundamentos de Java","text":""},{"location":"spring/#1-que-diferencias-hay-entre-una-interfaz-y-una-clase-abstracta-en-java","title":"1. \u00bfQu\u00e9 diferencias hay entre una interfaz y una clase abstracta en Java?","text":"<p>Una interfaz define un contrato que las clases deben implementar, mientras que una clase abstracta puede contener implementaci\u00f3n parcial. Desde Java 8, las interfaces tambi\u00e9n pueden tener m\u00e9todos con implementaci\u00f3n (<code>default</code>). Sin embargo, una clase solo puede extender una clase abstracta, pero puede implementar m\u00faltiples interfaces.</p>"},{"location":"spring/#2-que-significa-que-java-tenga-pass-by-value","title":"2. \u00bfQu\u00e9 significa que Java tenga \"pass-by-value\"?","text":"<p>En Java, todo se pasa por valor. Para tipos primitivos se pasa una copia del valor. Para objetos, se pasa una copia de la referencia, lo que significa que puedes modificar el objeto referenciado, pero no cambiar la referencia original.</p>"},{"location":"spring/#3-que-diferencia-hay-entre-y-equals-en-java","title":"3. \u00bfQu\u00e9 diferencia hay entre == y .equals() en Java?","text":"<p><code>==</code> compara referencias (si apuntan al mismo objeto). <code>.equals()</code> compara el contenido del objeto. Por ejemplo, dos String diferentes pueden tener el mismo contenido, pero estar en posiciones distintas de memoria.</p>"},{"location":"spring/#4-que-es-el-heap-y-la-stack-en-la-memoria-de-java","title":"4. \u00bfQu\u00e9 es el heap y la stack en la memoria de Java?","text":"<ul> <li>Stack: Almacena variables locales y llamadas a m\u00e9todos.</li> <li>Heap: Almacena objetos creados con <code>new</code>.</li> <li>El recolector de basura (GC) limpia el heap cuando ya no hay referencias.</li> </ul>"},{"location":"spring/#5-para-que-sirve-final-en-clases-metodos-o-variables","title":"5. \u00bfPara qu\u00e9 sirve final en clases, m\u00e9todos o variables?","text":"<ul> <li>En variables: Impide su modificaci\u00f3n.</li> <li>En m\u00e9todos: No se pueden sobrescribir.</li> <li>En clases: No se pueden heredar.</li> </ul>"},{"location":"spring/#programacion-orientada-a-objetos-poo","title":"Programaci\u00f3n Orientada a Objetos (POO)","text":""},{"location":"spring/#6-que-es-el-principio-de-inversion-de-dependencias-dip","title":"6. \u00bfQu\u00e9 es el principio de inversi\u00f3n de dependencias (DIP)?","text":"<p>Establece que las clases de alto nivel no deben depender de clases de bajo nivel, sino de abstracciones. Tambi\u00e9n, las abstracciones no deben depender de detalles, sino los detalles de las abstracciones. Se logra mediante interfaces e inyecci\u00f3n de dependencias.</p>"},{"location":"spring/#7-como-aplicas-la-herencia-y-la-composicion-cuando-usarias-cada-una","title":"7. \u00bfC\u00f3mo aplicas la herencia y la composici\u00f3n? \u00bfCu\u00e1ndo usar\u00edas cada una?","text":"<ul> <li>Herencia: Relaci\u00f3n \"es-un\" (<code>Perro extends Animal</code>).</li> <li>Composici\u00f3n: Relaci\u00f3n \"tiene-un\" (<code>Coche</code> tiene un <code>Motor</code>).</li> <li>La composici\u00f3n es m\u00e1s flexible y favorece el bajo acoplamiento.</li> </ul>"},{"location":"spring/#8-que-es-el-polimorfismo-en-java","title":"8. \u00bfQu\u00e9 es el polimorfismo en Java?","text":"<p>Es la capacidad de usar objetos de diferentes clases a trav\u00e9s de una referencia com\u00fan. Por ejemplo, un m\u00e9todo que acepta un par\u00e1metro de tipo <code>Animal</code> puede trabajar con <code>Perro</code>, <code>Gato</code>, etc.</p>"},{"location":"spring/#9-se-puede-sobrescribir-override-un-metodo-estatico","title":"9. \u00bfSe puede sobrescribir (override) un m\u00e9todo est\u00e1tico?","text":"<p>No. Los m\u00e9todos est\u00e1ticos pertenecen a la clase, no a la instancia. No pueden sobrescribirse, solo ocultarse (hiding).</p>"},{"location":"spring/#10-que-es-super-y-this","title":"10. \u00bfQu\u00e9 es super y this?","text":"<ul> <li>this: Se refiere a la instancia actual.</li> <li>super: Se usa para acceder a la clase padre (por ejemplo, su constructor o m\u00e9todos).</li> </ul>"},{"location":"spring/#colecciones-y-streams","title":"Colecciones y Streams","text":""},{"location":"spring/#11-cual-es-la-diferencia-entre-list-set-y-map","title":"11. \u00bfCu\u00e1l es la diferencia entre List, Set y Map?","text":"<ul> <li>List: Mantiene orden, permite duplicados.</li> <li>Set: No permite duplicados, puede no mantener orden.</li> <li>Map: Almacena pares clave-valor, no permite claves duplicadas.</li> </ul>"},{"location":"spring/#12-para-que-sirve-optional-en-java","title":"12. \u00bfPara qu\u00e9 sirve Optional en Java?","text":"<p>Es una forma segura de representar valores que pueden estar presentes o no. Ayuda a evitar <code>NullPointerException</code>.</p>"},{"location":"spring/#13-que-hace-este-fragmento-de-codigo","title":"13. \u00bfQu\u00e9 hace este fragmento de c\u00f3digo?","text":"<p><pre><code>List&lt;String&gt; nombres = List.of(\"Ana\", \"Luis\", \"Carlos\");\nnombres.stream()\n .filter(n -&gt; n.length() &gt; 3)\n .map(String::toUpperCase)\n .forEach(System.out::println);\n</code></pre> Filtra los nombres con m\u00e1s de 3 letras, los convierte a may\u00fasculas y los imprime: <pre><code>LUIS\nCARLOS\n</code></pre></p>"},{"location":"spring/#manejo-de-errores","title":"Manejo de Errores","text":""},{"location":"spring/#14-cual-es-la-diferencia-entre-throw-y-throws","title":"14. \u00bfCu\u00e1l es la diferencia entre throw y throws?","text":"<ul> <li>throw: Lanza una excepci\u00f3n.</li> <li>throws: Declara que un m\u00e9todo puede lanzar una excepci\u00f3n (checked).</li> </ul>"},{"location":"spring/#15-que-son-las-excepciones-checked-y-unchecked","title":"15. \u00bfQu\u00e9 son las excepciones checked y unchecked?","text":"<ul> <li>Checked: Deben capturarse o declararse (ej. <code>IOException</code>).</li> <li>Unchecked: No es obligatorio capturarlas (<code>NullPointerException</code>, <code>IllegalArgumentException</code>, etc.).</li> </ul>"},{"location":"spring/#archivos-http-json-y-concurrencia","title":"Archivos, HTTP, JSON y Concurrencia","text":""},{"location":"spring/#16-como-leer-y-escribir-archivos-en-java-moderno","title":"16. \u00bfC\u00f3mo leer y escribir archivos en Java moderno?","text":"<ul> <li>Leer: <code>Files.readAllLines(path)</code> o <code>Files.lines(path)</code></li> <li>Escribir: <code>Files.write(path, List&lt;String&gt;)</code></li> </ul>"},{"location":"spring/#17-como-haces-una-peticion-http-en-java-sin-usar-spring","title":"17. \u00bfC\u00f3mo haces una petici\u00f3n HTTP en Java sin usar Spring?","text":"<p>Con HttpClient de Java 11: <pre><code>HttpClient client = HttpClient.newHttpClient();\nHttpRequest request = HttpRequest.newBuilder()\n .uri(URI.create(\"https://api.example.com\"))\n .build();\nHttpResponse&lt;String&gt; response = client.send(request, BodyHandlers.ofString());\n</code></pre></p>"},{"location":"spring/#18-como-convertir-un-objeto-a-json-y-viceversa","title":"18. \u00bfC\u00f3mo convertir un objeto a JSON y viceversa?","text":"<p>Usando Jackson y ObjectMapper: <pre><code>ObjectMapper mapper = new ObjectMapper();\nString json = mapper.writeValueAsString(obj);\nMiClase nuevo = mapper.readValue(json, MiClase.class);\n</code></pre></p>"},{"location":"spring/#19-cual-es-la-diferencia-entre-synchronized-executorservice-y-parallelstream","title":"19. \u00bfCu\u00e1l es la diferencia entre synchronized, ExecutorService y parallelStream()?","text":"<ul> <li>synchronized: Control de acceso exclusivo a secciones cr\u00edticas.</li> <li>ExecutorService: Gesti\u00f3n avanzada de hilos y tareas.</li> <li>parallelStream(): Procesamiento paralelo declarativo.</li> </ul>"},{"location":"spring/#testing-y-buenas-practicas","title":"Testing y Buenas Pr\u00e1cticas","text":""},{"location":"spring/#20-que-tipo-de-test-harias-para-asegurar-que-un-controlador-devuelve-correctamente-un-codigo-200","title":"20. \u00bfQu\u00e9 tipo de test har\u00edas para asegurar que un controlador devuelve correctamente un c\u00f3digo 200?","text":"<p>Test de integraci\u00f3n con MockMvc o WebTestClient, validando el status, contenido y cabeceras.</p>"},{"location":"spring/#21-que-patrones-de-diseno-conoces-y-cuales-has-usado-en-tus-proyectos","title":"21. \u00bfQu\u00e9 patrones de dise\u00f1o conoces y cu\u00e1les has usado en tus proyectos?","text":""},{"location":"spring/#patrones-creacionales","title":"Patrones Creacionales:","text":"<ul> <li> <p>Singleton: Garantiza una \u00fanica instancia de una clase.   <pre><code>public class ConexionBD {\n    private static ConexionBD instancia;\n    private ConexionBD() { /* Constructor privado */ }\n\n    public static synchronized ConexionBD getInstancia() {\n        if (instancia == null) {\n            instancia = new ConexionBD();\n        }\n        return instancia;\n    }\n}\n</code></pre> Ejemplo real: Gestor de configuraci\u00f3n de aplicaci\u00f3n que debe ser \u00fanico.</p> </li> <li> <p>Factory Method: Define una interfaz para crear objetos, pero permite a las subclases decidir qu\u00e9 clase instanciar.</p> </li> </ul> <p><pre><code>interface Notificacion { void enviar(String mensaje); }\nclass Email implements Notificacion { /*...*/ }\nclass SMS implements Notificacion { /*...*/ }\n\nclass NotificacionFactory {\n    public Notificacion crearNotificacion(String canal) {\n        if (canal.equals(\"email\")) return new Email();\n        else if (canal.equals(\"sms\")) return new SMS();\n        return null;\n    }\n}\n</code></pre> Ejemplo real: Sistema de pagos con diferentes procesadores (PayPal, Stripe, etc.)</p> <ul> <li>Builder: Separa la construcci\u00f3n de un objeto complejo de su representaci\u00f3n.</li> </ul> <p><pre><code>class Usuario {\n    private final String nombre;\n    private final int edad;\n    // Constructor privado\n    private Usuario(Builder builder) {\n        this.nombre = builder.nombre;\n        this.edad = builder.edad;\n    }\n\n    public static class Builder {\n        private String nombre;\n        private int edad;\n\n        public Builder nombre(String nombre) {\n            this.nombre = nombre;\n            return this;\n        }\n\n        public Builder edad(int edad) {\n            this.edad = edad;\n            return this;\n        }\n\n        public Usuario build() {\n            return new Usuario(this);\n        }\n    }\n}\n\n// Uso\nUsuario usuario = new Usuario.Builder()\n    .nombre(\"Juan\")\n    .edad(30)\n    .build();\n</code></pre> Ejemplo real: Construcci\u00f3n de objetos de configuraci\u00f3n con muchos par\u00e1metros opcionales.</p>"},{"location":"spring/#patrones-estructurales","title":"Patrones Estructurales:","text":"<ul> <li> <p>Adapter: Permite que interfaces incompatibles trabajen juntas.   <pre><code>interface ClienteAPI {\n    void procesarDatos(String[] datos);\n}\n\nclass SistemaLegado {\n    public void procesarInformacion(List&lt;String&gt; info) {\n        // L\u00f3gica existente\n    }\n}\n\nclass SistemaLegadoAdapter implements ClienteAPI {\n    private SistemaLegado legado;\n\n    public SistemaLegadoAdapter(SistemaLegado legado) {\n        this.legado = legado;\n    }\n\n    @Override\n    public void procesarDatos(String[] datos) {\n        legado.procesarInformacion(Arrays.asList(datos));\n    }\n}\n</code></pre> Ejemplo real: Integraci\u00f3n con bibliotecas o APIs de terceros con interfaces diferentes.</p> </li> <li> <p>Repository: Abstrae el acceso a la capa de datos.   <pre><code>interface UsuarioRepository {\n    Usuario findById(Long id);\n    void save(Usuario usuario);\n}\n\nclass UsuarioRepositoryImpl implements UsuarioRepository {\n    @Override\n    public Usuario findById(Long id) {\n        // L\u00f3gica de acceso a base de datos\n        return usuario;\n    }\n\n    @Override\n    public void save(Usuario usuario) {\n        // Persistir en base de datos\n    }\n}\n</code></pre> Ejemplo real: Capa de acceso a datos en aplicaciones empresariales.</p> </li> </ul>"},{"location":"spring/#patrones-de-comportamiento","title":"Patrones de Comportamiento:","text":"<ul> <li> <p>Strategy: Define una familia de algoritmos, encapsula cada uno y los hace intercambiables.   <pre><code>interface EstrategiaPago {\n    void pagar(double monto);\n}\n\nclass PagoTarjeta implements EstrategiaPago {\n    public void pagar(double monto) { /*...*/ }\n}\n\nclass PagoPayPal implements EstrategiaPago {\n    public void pagar(double monto) { /*...*/ }\n}\n\nclass Compra {\n    private EstrategiaPago estrategia;\n\n    public void setEstrategiaPago(EstrategiaPago estrategia) {\n        this.estrategia = estrategia;\n    }\n\n    public void realizarPago(double monto) {\n        estrategia.pagar(monto);\n    }\n}\n</code></pre> Ejemplo real: Diferentes algoritmos de c\u00e1lculo de impuestos seg\u00fan el pa\u00eds.</p> </li> <li> <p>Observer: Define una dependencia uno a muchos entre objetos, de modo que cuando un objeto cambia su estado, todos sus dependientes son notificados.   <pre><code>interface Observer {\n    void actualizar(String mensaje);\n}\n\nclass Suscriptor implements Observer {\n    private String nombre;\n\n    public Suscriptor(String nombre) {\n        this.nombre = nombre;\n    }\n\n    @Override\n    public void actualizar(String mensaje) {\n        System.out.println(nombre + \" recibi\u00f3: \" + mensaje);\n    }\n}\n\nclass NotificadorEventos {\n    private List&lt;Observer&gt; observadores = new ArrayList&lt;&gt;();\n\n    public void agregarObservador(Observer o) {\n        observadores.add(o);\n    }\n\n    public void notificarTodos(String mensaje) {\n        for (Observer o : observadores) {\n            o.actualizar(mensaje);\n        }\n    }\n}\n</code></pre> Ejemplo real: Sistema de notificaciones en tiempo real en aplicaciones web.</p> </li> </ul>"},{"location":"spring/#21b-principios-solid-con-ejemplos-practicos","title":"21b. Principios SOLID con ejemplos pr\u00e1cticos","text":""},{"location":"spring/#s-principio-de-responsabilidad-unica-srp","title":"S - Principio de Responsabilidad \u00danica (SRP)","text":"<p>Una clase debe tener una sola raz\u00f3n para cambiar.</p> <p>Ejemplo: Un servicio de Facturaci\u00f3n no debe ocuparse de la l\u00f3gica de c\u00e1lculo de impuestos, env\u00edo de correos y persistencia de datos.</p> <pre><code>// MAL: Clase con m\u00faltiples responsabilidades\nclass Factura {\n    public void calcularTotal() { /*...*/ }\n    public void guardarEnBD() { /*...*/ }\n    public void enviarPorEmail() { /*...*/ }\n}\n\n// BIEN: Separaci\u00f3n de responsabilidades\nclass Factura {\n    public void calcularTotal() { /*...*/ }\n}\n\nclass RepositorioFacturas {\n    public void guardar(Factura factura) { /*...*/ }\n}\n\nclass NotificadorFacturas {\n    public void enviarPorEmail(Factura factura) { /*...*/ }\n}\n</code></pre> <p>Ejemplo real: En una aplicaci\u00f3n de e-commerce, separar la l\u00f3gica de procesamiento de pagos de la l\u00f3gica de inventario.</p>"},{"location":"spring/#o-principio-de-abiertocerrado-ocp","title":"O - Principio de Abierto/Cerrado (OCP)","text":"<p>Las entidades deben estar abiertas para extensi\u00f3n pero cerradas para modificaci\u00f3n.</p> <p>Ejemplo: A\u00f1adir nuevos tipos de descuentos sin modificar el c\u00e1lculo existente.</p> <pre><code>// Dise\u00f1o cerrado para extensi\u00f3n\nclass CalculadorPrecio {\n    public double calcularPrecioFinal(Producto p) {\n        if (p.esAlimentacion()) return p.getPrecio() * 0.9;\n        if (p.esElectronica()) return p.getPrecio() * 0.8;\n        return p.getPrecio();\n    }\n}\n\n// Dise\u00f1o abierto para extensi\u00f3n\ninterface EstrategiaDescuento {\n    double aplicarDescuento(double precio);\n}\n\nclass DescuentoAlimentacion implements EstrategiaDescuento {\n    public double aplicarDescuento(double precio) { return precio * 0.9; }\n}\n\nclass DescuentoElectronica implements EstrategiaDescuento {\n    public double aplicarDescuento(double precio) { return precio * 0.8; }\n}\n\nclass CalculadorPrecio {\n    public double calcularPrecioFinal(Producto p, EstrategiaDescuento descuento) {\n        return descuento.aplicarDescuento(p.getPrecio());\n    }\n}\n</code></pre> <p>Ejemplo real: Sistema de procesamiento de pagos que permite a\u00f1adir nuevas pasarelas de pago sin modificar el c\u00f3digo existente.</p>"},{"location":"spring/#l-principio-de-sustitucion-de-liskov-lsp","title":"L - Principio de Sustituci\u00f3n de Liskov (LSP)","text":"<p>Las subclases deben poder ser sustituidas por sus clases base sin alterar el comportamiento.</p> <p>Ejemplo: Todas las aves pueden volar... \u00bfo no?</p> <pre><code>// MAL: Viola LSP\nclass Ave {\n    public void volar() { /*...*/ }\n}\n\nclass Pinguino extends Ave {\n    @Override\n    public void volar() {\n        throw new UnsupportedOperationException(\"Los ping\u00fcinos no vuelan\");\n    }\n}\n\n// BIEN: Respeta LSP\ninterface AvesQueVuelan {\n    void volar();\n}\n\nclass Ave {\n    // Comportamiento com\u00fan a todas las aves\n}\n\nclass Golondrina extends Ave implements AvesQueVuelan {\n    public void volar() { /*...*/ }\n}\n\nclass Pinguino extends Ave {\n    // No implementa AvesQueVuelan\n}\n</code></pre> <p>Ejemplo real: En un sistema bancario, diferentes tipos de cuentas (Ahorro, Corriente) deben poder usarse de manera intercambiable en operaciones b\u00e1sicas.</p>"},{"location":"spring/#i-principio-de-segregacion-de-interfaces-isp","title":"I - Principio de Segregaci\u00f3n de Interfaces (ISP)","text":"<p>Ning\u00fan cliente debe verse forzado a depender de m\u00e9todos que no usa.</p> <p>Ejemplo: Una impresora multifunci\u00f3n tiene diferentes capacidades.</p> <pre><code>// MAL: Interfaz sobrecargada\ninterface DispositivoOficina {\n    void imprimir();\n    void escanear();\n    void enviarFax();\n    void grapar();\n}\n\n// BIEN: Interfaces segregadas\ninterface Impresora {\n    void imprimir();\n}\n\ninterface Escaner {\n    void escanear();\n}\n\ninterface Fax {\n    void enviarFax();\n}\n\nclass ImpresoraSimple implements Impresora {\n    public void imprimir() { /*...*/ }\n}\n\nclass DispositivoMultifuncion implements Impresora, Escaner, Fax {\n    public void imprimir() { /*...*/ }\n    public void escanear() { /*...*/ }\n    public void enviarFax() { /*...*/ }\n}\n</code></pre> <p>Ejemplo real: API de pagos que ofrece interfaces espec\u00edficas para diferentes funcionalidades: procesamiento de pagos, reembolsos, suscripciones.</p>"},{"location":"spring/#d-principio-de-inversion-de-dependencias-dip","title":"D - Principio de Inversi\u00f3n de Dependencias (DIP)","text":"<p>Los m\u00f3dulos de alto nivel no deben depender de m\u00f3dulos de bajo nivel. Ambos deben depender de abstracciones.</p> <p>Ejemplo: Un servicio no debe depender directamente de la implementaci\u00f3n de la base de datos.</p> <pre><code>// MAL: Dependencia directa\nclass ServicioUsuario {\n    private RepositorioUsuarioMySQL repo = new RepositorioUsuarioMySQL();\n\n    public Usuario buscar(Long id) {\n        return repo.findById(id);\n    }\n}\n\n// BIEN: Dependencia en abstracci\u00f3n\ninterface RepositorioUsuario {\n    Usuario findById(Long id);\n}\n\nclass RepositorioUsuarioMySQL implements RepositorioUsuario {\n    public Usuario findById(Long id) { /*...*/ }\n}\n\nclass ServicioUsuario {\n    private RepositorioUsuario repo;\n\n    // Inyecci\u00f3n de dependencia\n    public ServicioUsuario(RepositorioUsuario repo) {\n        this.repo = repo;\n    }\n\n    public Usuario buscar(Long id) {\n        return repo.findById(id);\n    }\n}\n</code></pre> <p>Ejemplo real: Una aplicaci\u00f3n empresarial que abstrae el acceso a datos permitiendo cambiar entre diferentes bases de datos (MySQL, MongoDB, etc.) sin afectar la l\u00f3gica de negocio.</p>"},{"location":"spring/#java-moderno","title":"Java Moderno","text":""},{"location":"spring/#22-que-diferencias-hay-entre-array-y-arraylist","title":"22. \u00bfQu\u00e9 diferencias hay entre Array y ArrayList?","text":"<ul> <li>Array: Tama\u00f1o fijo, puede contener tipos primitivos.</li> <li>ArrayList: Tama\u00f1o din\u00e1mico, solo objetos, ofrece m\u00e9todos como <code>add()</code>, <code>remove()</code>.</li> </ul>"},{"location":"spring/#23-que-es-var-en-java","title":"23. \u00bfQu\u00e9 es var en Java?","text":"<p>Desde Java 10, permite inferencia de tipo local. El tipo es est\u00e1tico y se infiere en tiempo de compilaci\u00f3n: <pre><code>var lista = new ArrayList&lt;String&gt;();\n</code></pre></p>"},{"location":"spring/#24-que-es-un-enum-y-cuando-se-usa","title":"24. \u00bfQu\u00e9 es un enum y cu\u00e1ndo se usa?","text":"<p>Un enum representa un conjunto fijo de constantes. \u00datil para modelar categor\u00edas o estados como <code>DIA</code>, <code>NOCHE</code>, <code>ESTADO.ACTIVO</code>.</p>"},{"location":"spring/#25-que-es-un-record-en-java","title":"25. \u00bfQu\u00e9 es un record en Java?","text":"<p>Introducido en Java 14+, define una clase inmutable con m\u00ednimo c\u00f3digo: <pre><code>record Usuario(String nombre, int edad) {}\n</code></pre></p>"},{"location":"spring/#26-que-es-la-inferencia-de-tipos-en-lambdas","title":"26. \u00bfQu\u00e9 es la inferencia de tipos en lambdas?","text":"<p>Java deduce el tipo de par\u00e1metros en funciones lambda autom\u00e1ticamente: <pre><code>lista.forEach(item -&gt; System.out.println(item));\n</code></pre></p>"},{"location":"spring/#27-para-que-se-usa-el-patron-builder","title":"27. \u00bfPara qu\u00e9 se usa el patr\u00f3n Builder?","text":"<p>Para construir objetos complejos paso a paso, evitando constructores con muchos par\u00e1metros y mejorando la legibilidad.</p>"},{"location":"spring/#fundamentos-de-spring-boot","title":"Fundamentos de Spring Boot","text":""},{"location":"spring/#28-que-diferencia-hay-entre-component-service-repository-y-controller","title":"28. \u00bfQu\u00e9 diferencia hay entre @Component, @Service, @Repository y @Controller?","text":"<p>Todos son estereotipos de Spring que marcan una clase como un componente a gestionar. <code>@Component</code> es gen\u00e9rico, <code>@Service</code> se usa para l\u00f3gica de negocio, <code>@Repository</code> para acceso a datos (adem\u00e1s traduce excepciones autom\u00e1ticamente), y <code>@Controller</code> para controlar las peticiones HTTP.</p>"},{"location":"spring/#29-que-funcion-cumple-el-archivo-applicationproperties-o-applicationyml","title":"29. \u00bfQu\u00e9 funci\u00f3n cumple el archivo application.properties o application.yml?","text":"<p>Permite definir la configuraci\u00f3n de la aplicaci\u00f3n: puertos, datos de conexi\u00f3n, variables personalizadas, perfiles activos, propiedades de Spring, entre otros.</p>"},{"location":"spring/#controladores-y-manejo-http","title":"Controladores y manejo HTTP","text":""},{"location":"spring/#30-que-diferencia-hay-entre-getmapping-y-requestmappingmethod-requestmethodget","title":"30. \u00bfQu\u00e9 diferencia hay entre @GetMapping y @RequestMapping(method = RequestMethod.GET)?","text":"<p><code>@GetMapping</code> es una anotaci\u00f3n espec\u00edfica para simplificar <code>@RequestMapping(method = RequestMethod.GET)</code>, haci\u00e9ndolo m\u00e1s legible. Ambas hacen lo mismo, pero <code>@GetMapping</code> es m\u00e1s concisa.</p>"},{"location":"spring/#31-como-puedes-recibir-datos-de-una-peticion-post-en-spring-boot","title":"31. \u00bfC\u00f3mo puedes recibir datos de una petici\u00f3n POST en Spring Boot?","text":"<p>Utilizando un DTO o entidad como par\u00e1metro con <code>@RequestBody</code>. Spring deserializa autom\u00e1ticamente el cuerpo JSON en ese objeto.</p>"},{"location":"spring/#manejo-de-errores-y-excepciones","title":"Manejo de errores y excepciones","text":""},{"location":"spring/#32-que-es-un-controlleradvice","title":"32. \u00bfQu\u00e9 es un @ControllerAdvice?","text":"<p>Es una clase que maneja excepciones de manera global en todos los controladores. Permite capturar errores comunes y devolver respuestas personalizadas con <code>@ExceptionHandler</code>.</p>"},{"location":"spring/#33-como-personalizar-la-respuesta-de-error-para-una-excepcion-especifica","title":"33. \u00bfC\u00f3mo personalizar la respuesta de error para una excepci\u00f3n espec\u00edfica?","text":"<p>Se puede crear un m\u00e9todo con <code>@ExceptionHandler(NombreDeLaExcepcion.class)</code> dentro de una clase anotada con <code>@ControllerAdvice</code>, y devolver un objeto con el mensaje, c\u00f3digo de estado, etc.</p>"},{"location":"spring/#asincronia-concurrencia-y-tareas-programadas","title":"Asincron\u00eda, concurrencia y tareas programadas","text":""},{"location":"spring/#34-como-se-ejecuta-un-metodo-de-forma-asincrona-en-spring-boot","title":"34. \u00bfC\u00f3mo se ejecuta un m\u00e9todo de forma as\u00edncrona en Spring Boot?","text":"<p>Se anota el m\u00e9todo con <code>@Async</code> y se habilita el soporte con <code>@EnableAsync</code> en una clase de configuraci\u00f3n. El m\u00e9todo debe retornar <code>CompletableFuture</code>, <code>Future</code> o <code>void</code>.</p>"},{"location":"spring/#35-que-es-scheduled-y-como-se-usa","title":"35. \u00bfQu\u00e9 es @Scheduled y c\u00f3mo se usa?","text":"<p>Permite ejecutar tareas peri\u00f3dicas. Se configura con expresiones cron o par\u00e1metros como <code>fixedRate</code>. Requiere <code>@EnableScheduling</code>.</p>"},{"location":"spring/#auto-configuracion-y-estructura-base-de-spring-boot","title":"Auto configuraci\u00f3n y estructura base de Spring Boot","text":""},{"location":"spring/#36-que-es-la-auto-configuracion-en-spring-boot","title":"36. \u00bfQu\u00e9 es la auto configuraci\u00f3n en Spring Boot?","text":"<p>Es una funcionalidad que configura autom\u00e1ticamente beans comunes en funci\u00f3n de las dependencias del classpath. Esto elimina la necesidad de configurar todo manualmente y se activa con <code>@SpringBootApplication</code>.</p>"},{"location":"spring/#37-que-hace-la-anotacion-springbootapplication","title":"37. \u00bfQu\u00e9 hace la anotaci\u00f3n @SpringBootApplication?","text":"<p>Es una combinaci\u00f3n de <code>@Configuration</code>, <code>@EnableAutoConfiguration</code> y <code>@ComponentScan</code>. Marca el punto de entrada principal de la app y permite que Spring configure todo autom\u00e1ticamente.</p>"},{"location":"spring/#38-que-convenciones-sigue-spring-boot-para-buscar-beans","title":"38. \u00bfQu\u00e9 convenciones sigue Spring Boot para buscar beans?","text":"<p>Spring escanea autom\u00e1ticamente todos los paquetes hijos del paquete donde se encuentra la clase con <code>@SpringBootApplication</code>. Si los beans est\u00e1n fuera de ese \u00e1rbol de paquetes, no se detectar\u00e1n salvo que se especifique el <code>@ComponentScan</code>.</p>"},{"location":"spring/#39-que-diferencia-hay-entre-configuration-y-component","title":"39. \u00bfQu\u00e9 diferencia hay entre @Configuration y @Component?","text":"<p><code>@Configuration</code> define una clase que puede contener m\u00e9todos con <code>@Bean</code>, y est\u00e1 pensada para la configuraci\u00f3n de la aplicaci\u00f3n. <code>@Component</code> es una anotaci\u00f3n m\u00e1s gen\u00e9rica para cualquier clase que deba ser gestionada por el contenedor de Spring.</p>"},{"location":"spring/#spring-mvc-y-desarrollo-web","title":"Spring MVC y desarrollo Web","text":""},{"location":"spring/#40-que-hace-el-restcontroller","title":"40. \u00bfQu\u00e9 hace el @RestController?","text":"<p>Es una combinaci\u00f3n de <code>@Controller</code> y <code>@ResponseBody</code>, lo que permite que los m\u00e9todos devuelvan directamente datos (como JSON) sin necesidad de escribir <code>@ResponseBody</code> en cada uno.</p>"},{"location":"spring/#41-como-se-mapean-rutas-en-spring-boot-web","title":"41. \u00bfC\u00f3mo se mapean rutas en Spring Boot Web?","text":"<p>Usando anotaciones como <code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code>, etc., encima de m\u00e9todos dentro de un <code>@RestController</code>. Tambi\u00e9n se pueden usar <code>@RequestMapping</code> con el m\u00e9todo definido.</p>"},{"location":"spring/#42-como-se-accede-a-parametros-en-la-url","title":"42. \u00bfC\u00f3mo se accede a par\u00e1metros en la URL?","text":"<p>Usando <code>@PathVariable</code> para capturar partes de la ruta (<code>/users/{id}</code>), o <code>@RequestParam</code> para capturar par\u00e1metros tipo query (<code>/search?term=x</code>).</p>"},{"location":"spring/#43-que-diferencia-hay-entre-requestbody-y-modelattribute","title":"43. \u00bfQu\u00e9 diferencia hay entre @RequestBody y @ModelAttribute?","text":"<p><code>@RequestBody</code> toma el cuerpo crudo de la petici\u00f3n (generalmente JSON) y lo deserializa en un objeto. <code>@ModelAttribute</code> toma datos del formulario o query params, \u00fatil para formularios en apps web tradicionales.</p>"},{"location":"spring/#44-como-se-devuelven-respuestas-personalizadas-en-spring-boot","title":"44. \u00bfC\u00f3mo se devuelven respuestas personalizadas en Spring Boot?","text":"<p>Usando objetos <code>ResponseEntity&lt;T&gt;</code> que permiten controlar el cuerpo de la respuesta, cabeceras y c\u00f3digo de estado HTTP.</p>"},{"location":"spring/#validaciones-en-spring-boot","title":"Validaciones en Spring Boot","text":""},{"location":"spring/#45-como-se-activan-las-validaciones-en-un-controlador-de-spring-boot","title":"45. \u00bfC\u00f3mo se activan las validaciones en un controlador de Spring Boot?","text":"<p>Usando <code>@Valid</code> o <code>@Validated</code> en el par\u00e1metro del m\u00e9todo del controlador. Spring valida autom\u00e1ticamente los atributos anotados con <code>@NotNull</code>, <code>@Size</code>, <code>@Email</code>, etc., y lanza una excepci\u00f3n si no se cumplen.</p>"},{"location":"spring/#46-como-se-personaliza-el-mensaje-de-error-de-una-validacion","title":"46. \u00bfC\u00f3mo se personaliza el mensaje de error de una validaci\u00f3n?","text":"<p>Se puede usar el atributo message en la anotaci\u00f3n, por ejemplo: <code>@NotNull(message = \"El nombre es obligatorio\")</code>. Tambi\u00e9n se pueden usar ficheros <code>.properties</code> para externalizar los mensajes.</p>"},{"location":"spring/#47-que-diferencia-hay-entre-valid-y-validated","title":"47. \u00bfQu\u00e9 diferencia hay entre @Valid y @Validated?","text":"<p><code>@Valid</code> es de Javax y se usa principalmente en controladores. <code>@Validated</code> es de Spring y permite validaciones por grupos o validaciones a nivel de servicio, no solo en controladores.</p>"},{"location":"spring/#48-como-se-gestionan-los-errores-de-validacion","title":"48. \u00bfC\u00f3mo se gestionan los errores de validaci\u00f3n?","text":"<p>Spring lanza una excepci\u00f3n (<code>MethodArgumentNotValidException</code>) que se puede capturar con <code>@ControllerAdvice</code> y un m\u00e9todo con <code>@ExceptionHandler</code>.</p>"},{"location":"spring/#testing-en-spring-boot-web","title":"Testing en Spring Boot Web","text":""},{"location":"spring/#49-que-hace-webmvctest","title":"49. \u00bfQu\u00e9 hace @WebMvcTest?","text":"<p>Carga solo el contexto relacionado con Spring MVC (controladores, filtros, validaciones), ignorando servicios, repositorios y dem\u00e1s beans. Ideal para pruebas unitarias de controladores.</p>"},{"location":"spring/#50-que-herramienta-se-usa-para-simular-peticiones-http","title":"50. \u00bfQu\u00e9 herramienta se usa para simular peticiones HTTP?","text":"<p><code>MockMvc</code> permite hacer peticiones simuladas a endpoints (<code>GET</code>, <code>POST</code>, etc.), verificar c\u00f3digos de estado, cabeceras y contenido del JSON de respuesta.</p>"},{"location":"spring/#51-que-diferencia-hay-entre-springboottest-y-webmvctest","title":"51. \u00bfQu\u00e9 diferencia hay entre @SpringBootTest y @WebMvcTest?","text":"<p><code>@SpringBootTest</code> carga todo el contexto de Spring (ideal para tests de integraci\u00f3n). <code>@WebMvcTest</code> solo carga el contexto web para tests de controladores.</p>"},{"location":"spring/#mapeo-entre-capas-dtos-entidades-y-modelos","title":"Mapeo entre capas (DTOs, entidades y modelos)","text":""},{"location":"spring/#52-que-es-un-dto-y-por-que-se-usa","title":"52. \u00bfQu\u00e9 es un DTO y por qu\u00e9 se usa?","text":"<p>Un DTO (Data Transfer Object) es un objeto dise\u00f1ado para intercambiar datos entre capas, evitando exponer entidades directamente. Mejora la seguridad y desacopla las capas.</p>"},{"location":"spring/#53-como-se-realiza-el-mapeo-entre-entidad-y-dto","title":"53. \u00bfC\u00f3mo se realiza el mapeo entre entidad y DTO?","text":"<p>Se puede hacer manualmente en un mapper (por ejemplo, un m\u00e9todo <code>fromEntity()</code> y <code>toEntity()</code>), o autom\u00e1ticamente usando librer\u00edas como MapStruct o ModelMapper.</p>"},{"location":"spring/#54-que-ventajas-ofrece-mapstruct","title":"54. \u00bfQu\u00e9 ventajas ofrece MapStruct?","text":"<p>MapStruct genera c\u00f3digo en tiempo de compilaci\u00f3n, es r\u00e1pido, seguro y f\u00e1cil de mantener. Reduce el boilerplate y errores comunes en el mapeo manual.</p>"},{"location":"spring/#55-por-que-no-se-deben-exponer-directamente-las-entidades-jpa-en-los-controladores","title":"55. \u00bfPor qu\u00e9 no se deben exponer directamente las entidades JPA en los controladores?","text":"<p>Porque puede generar problemas de seguridad, acoplamiento, rendimiento (lazy loading), y dificulta la evoluci\u00f3n del modelo de dominio.</p>"},{"location":"spring/#arquitectura-y-diseno-en-spring-boot-web","title":"Arquitectura y dise\u00f1o en Spring Boot Web","text":""},{"location":"spring/#56-cual-es-la-estructura-mas-comun-en-una-app-spring-boot","title":"56. \u00bfCu\u00e1l es la estructura m\u00e1s com\u00fan en una app Spring Boot?","text":"<p>Una estructura por capas: <code>controller</code>, <code>service</code>, <code>repository</code>, <code>model</code> y <code>dto</code>. A veces se usa una estructura m\u00e1s vertical por funcionalidades.</p>"},{"location":"spring/#57-que-beneficios-aporta-la-arquitectura-en-capas","title":"57. \u00bfQu\u00e9 beneficios aporta la arquitectura en capas?","text":"<p>Separaci\u00f3n de responsabilidades, mejor mantenibilidad, testabilidad y facilidad para aplicar principios SOLID.</p>"},{"location":"spring/#58-que-es-el-service-y-que-hace","title":"58. \u00bfQu\u00e9 es el @Service y qu\u00e9 hace?","text":"<p>Es una anotaci\u00f3n de Spring que marca una clase como componente de negocio. Permite separar la l\u00f3gica de negocio del controlador.</p>"}]}